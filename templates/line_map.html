{% extends 'base.html' %}

{% block title %}线路图{% endblock %}

{% block header_subtitle %}
{% if is_loop %}
    {% set ring_label = '内环运行' if direction|int == 1 else '外环运行' %}
    {% if loop_has_terminal and loop_terminal_station %}
        {{ ring_label }} 终点站：<strong>{{ loop_terminal_station }}</strong>
        <div class="line-sub-info-en">{% if direction|int == 1 %}Inner Loop{% else %}Outer Loop{% endif %} Terminal: <strong>{{ trans_data.get(loop_terminal_station, loop_terminal_station).replace('<br>', ' ') }}</strong></div>
    {% else %}
        <strong>{{ ring_label }}</strong>
        <div class="line-sub-info-en">{% if direction|int == 1 %}Inner Loop{% else %}Outer Loop{% endif %}</div>
    {% endif %}
{% else %}
    {% set terminal_station_for_dir = '' %}
    {% if current_route_stations and current_route_stations|length > 0 %}
        {% if direction|int == 0 %}
            {% set terminal_station_for_dir = current_route_stations[-1] %}
        {% else %}
            {% set terminal_station_for_dir = current_route_stations[0] %}
        {% endif %}
    {% elif line_info and line_info|length > 0 %}
        {% set terminal_station_for_dir = (line_info[-1].station_name if direction|int == 0 else line_info[0].station_name) %}
    {% endif %}
    终点站：<strong>{{ terminal_station_for_dir }}</strong>
    <div class="line-sub-info-en">Terminal: <strong>{{ trans_data.get(terminal_station_for_dir, terminal_station_for_dir).replace('<br>', ' ') }}</strong></div>
{% endif %}
{% endblock %}

{% block page_title %}
    <div class="next-station-title">
        <div class="next-topline">
            <span class="next-station-label">下一站</span>
            <span class="next-station-label" style="font-size: 12px;">Next Station</span>
            {% if transfer_badges and transfer_badges|length > 0 %}
            <div class="next-station-transfers">
                <span class="transfer-label">换乘</span>
                <span class="transfer-label" style="font-size: 13px;">Transfer</span>
                <span class="next-transfer-badges">
                    {% for b in transfer_badges %}
                    <span class="transfer-badge {% if b.code|string|length > 1 %}wide{% endif %}" data-color="{{ b.color }}">{{ b.code }}</span>
                    {% endfor %}
                </span>
            </div>
            {% endif %}
        </div>
        <span class="next-station-name">{{ next_station }}</span>
        <span class="next-station-name-en">{{ trans_data.get(next_station, next_station).replace('<br>', ' ') }}</span>
    </div>
{% endblock %}

{% block head %}
<style>
    .next-station-title {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
    }
    .next-topline { display: inline-flex; align-items: center; gap: 10px; }
    .next-station-label {
        font-size: 18px;
        color: #fff;
        opacity: 0.9;
    }
    .transfer-label { font-size: 18px; color: #fff; opacity: 0.9; font-weight: normal; }
    .next-station-name {
        font-size: 32px;
        font-weight: bold;
        color: #fff;
    }
    .next-station-name-en {
        font-size: 16px;
        color: #fff;
        opacity: 0.8;
    }
    .next-station-transfers {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: #fff;
        opacity: 0.9;
        margin-top: 0; /* 与“下一站”同行显示，不用上边距 */
    }
    .next-transfer-badges { display: inline-flex; gap: 6px; }
    .transfer-badge { width: 22px; height: 22px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 12px; color: white; font-weight: bold; }
    
    .line-map-container {
        width: 100%;
        padding: 60px 0; /* 增大顶部间距 */
        min-height: 75vh; /* 增加画布高度：可根据需要调整比例 */
        overflow: hidden; /* 保证内容不超出白色画布 */
    }
    
    .line-map {
        position: relative;
        width: 100%;
    }
    
    .metro-line {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-start;
        gap: 25px;
        margin-top: 80px;
        margin-bottom: 40px;
        position: relative;
        width: 100%;
        padding: 0 40px;
    }
    
    .line-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 25px;
        position: relative;
        width: 100%;
        margin-bottom: 100px;
    }
    
    .line-row:last-child {
        margin-bottom: 0;
    }
    
    /* 反向行（偶数行） */
    .line-row.reverse {
        flex-direction: row-reverse;
        justify-content: space-between;
    }
    
    :root {
        --theme-color: #9b5de5;
        /* 箭头配置 */
        --arrow-size: 25px;
        --arrow-weight: 900;
        --arrow-color-black: #000;
        --arrow-color-gray: #555;
        --arrow-color-red: #ff3b30;
        --arrow-blink-duration: 1s;
    }
    /* 基础灰色轨道（已走过段） */
    .line-row::after {
        content: '';
        position: absolute;
        top: 50%;
        left: var(--rail-left, 0);
        width: var(--rail-width, 100%);
        height: 15px;
        background-color: #ddd;
        transform: translateY(-50%);
        border-radius: 8px;
        z-index: 0;
    }
    /* 彩色未走过轨道段（从下一站开始） */
    .line-row::before {
        content: '';
        position: absolute;
        top: 50%;
        left: var(--rail-colored-left, var(--rail-left, 0));
        width: var(--rail-colored-width, 0);
        height: 15px;
        background-color: var(--theme-color);
        transform: translateY(-50%);
        border-radius: 8px;
        z-index: 1;
    }
    
    /* 连接线 - 行间连接 */
    .connector {
        position: absolute;
        background-color: #ddd;
        z-index: 0;
    }
    
    /* 垂直连接线 */
    .connector.vertical {
        width: 15px;
        height: var(--connector-height, 80px);
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 8px;
    }
    
    /* 水平连接线（用于反向行） */
    .connector.horizontal {
        width: var(--connector-width, 60px);
        height: 15px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 8px;
    }
    
    /* 方向箭头样式 */
    .direction-arrow {
        position: absolute;
        font-weight: var(--arrow-weight, 900);
        font-size: var(--arrow-size, 18px);
        line-height: 1;
        z-index: 1;
        pointer-events: none;
    }
    .direction-arrow.black { color: var(--arrow-color-black, #000); }
    .direction-arrow.gray { color: var(--arrow-color-gray, #555); }
    .direction-arrow.red { color: var(--arrow-color-red, #ff3b30); animation: blink var(--arrow-blink-duration, 1s) infinite alternate; }
    
    /* 圆弧帽（连接水平与垂直） */
    .connector.cap {
        width: 15px;
        height: 15px;
        position: absolute;
        background-color: #ddd;
        border-radius: 50%;
        z-index: 0;
    }
    
    .station-node {
        position: relative;
        z-index: 2;
        min-width: 40px;
        width: 40px;
        height: 10px;
    }
    
    .station-circle {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #fff;
        border: 3px solid var(--theme-color);
        color: #fff;
        box-shadow: 0 0 0 3px #fff inset;
    }
    
    /* 仅下一站显示红点动画 */
    .station-circle.next::before {
        content: '';
        width: 10px;
        height: 10px;
        background: #ff3b30;
        border-radius: 50%;
        animation: blink 1s infinite alternate;
    }

    /* 下一站英文名加粗且红色 */
    .station-circle.next ~ .station-labels .station-name.en {
        color: #ff4757;
        font-weight: bold;
    }
    
    /* 已走过站点：灰色且无动态 */
    .station-circle.passed {
        background-color: #cfcfcf;
        border-color: #cfcfcf;
        box-shadow: 0 0 0 3px #cfcfcf inset;
    }

    /* 非当前子路线站点：灰色静止（不显示动画与彩环） */
    .station-circle.inactive {
        background-color: #eeeeee;
        border-color: #dddddd;
        box-shadow: 0 0 0 3px #eeeeee inset;
    }
    .station-name.inactive {
        color: #999999;
    }
    
    /* 换乘站：空心圆环，旋转彩环仅未走过时启用 */
    .station-circle.transfer {
        background-color: transparent;
        color: var(--theme-color);
        box-shadow: none;
        border: 4px solid var(--theme-color);
    }
    /* 非当前子路线的换乘站：环不旋转，边框改为中性灰，保持空心圆展示等分环 */
    .station-circle.transfer.inactive {
        background-color: transparent;
        border-color: #cccccc;
        box-shadow: none;
    }
    .station-circle.transfer::before {
        content: '';
        position: absolute;
        inset: 6px;
        border-radius: 50%;
        background: #fff;
        z-index: 1;
    }
    
    .station-labels {
        position: absolute;
        bottom: 25px;
        left: 50%;
        transform-origin: bottom left;
        transform: rotate(-45deg);
        text-align: left;
        width: 140px;
        display: flex;
        flex-direction: column-reverse;
        pointer-events: none;
    }
    .station-name {
        font-size: 13px;
        color: #333;
        text-align: left;
        line-height: 1.2;
        white-space: nowrap;
        font-weight: bold;
    }
    .station-name.current {
        color: #ff4757;
        font-weight: bold;
    }
    .station-name.en {
        font-size: 10px;
        color: #666;
        margin-top: 2px;
    }
    

    
    .transfer-badges {
        position: absolute;
        top: 25px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: row; /* 修改为水平排列 */
        flex-wrap: wrap; /* 允许换行 */
        width: 46px; /* 两个徽章宽度22*2 + 间距2 = 46px */
        justify-content: center; /* 单个徽章时居中对齐 */
        gap: 2px;
        z-index: 3;
    }
    .transfer-badge {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: white;
        font-weight: bold;
    }
    .transfer-badge.wide {
        width: auto;
        min-width: 22px;
        padding: 0 5px;
        border-radius: 11px;
    }
    
    
    /* 滚动条样式 */
    .line-map-container::-webkit-scrollbar { height: 8px; }
    .line-map-container::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 4px; }
    .line-map-container::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
    .line-map-container::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
    
    @keyframes blink { from { opacity: 0.2; } to { opacity: 1; } }
    @keyframes spin { to { transform: rotate(360deg); } }
</style>
{% endblock %}

{% block content %}
<div class="line-map-container">
    <div class="line-map" style="--theme-color: {{ line_color or '#9b5de5' }};">
        
        <!-- 普通线路容器 -->
        <div class="metro-line" id="metro-line">
            <!-- 线路行将通过JavaScript动态生成 -->
        </div>
        <!-- 环线容器 -->
        <div class="ring-line" id="ring-line" style="display:none;">
            <!-- SVG环形轨道与站点将通过JavaScript动态生成 -->
        </div>
        <!-- 将数据以JSON脚本标签形式注入，避免内联JS语法冲突 -->
        <script id="line-info-data" type="application/json">{{ line_info | tojson }}</script>
        <script id="current-route-stations-data" type="application/json">{{ current_route_stations | tojson }}</script>
        <script id="full-route-mode-data" type="application/json">{{ full_route_mode | tojson }}</script>
        <script id="next-station-data" type="application/json">{{ next_station | tojson }}</script>
        <script id="is-reversed-data" type="application/json">{{ is_reversed | tojson }}</script>
        <script id="is-loop-data" type="application/json">{{ is_loop | tojson }}</script>
        <script id="loop-has-terminal-data" type="application/json">{{ loop_has_terminal | tojson }}</script>
        <script id="loop-terminal-station-data" type="application/json">{{ loop_terminal_station | tojson }}</script>
        <script id="derection-data" type="application/json">{{ direction | tojson }}</script>
    </div>
</div>

<div class="navigation-buttons" style="margin-top: 30px; display: flex; justify-content: center; gap: 20px;">
    <button class="btn" onclick="navigateTo('/')">返回首页</button>
    <button class="btn" onclick="navigateTo('/line_detail')">线路详情</button>
</div>
{% endblock %}

{% block scripts %}
<script>
// 线路数据（从JSON脚本标签解析，避免模板语法影响JS解析）
const lineInfo = JSON.parse(document.getElementById('line-info-data')?.textContent || '[]');
const currentRouteStations = JSON.parse(document.getElementById('current-route-stations-data')?.textContent || '[]');
const fullRouteMode = JSON.parse(document.getElementById('full-route-mode-data')?.textContent || 'false');
const currentRouteSet = new Set(currentRouteStations);
const nextStationName = JSON.parse(document.getElementById('next-station-data')?.textContent || 'null');
const isReversed = JSON.parse(document.getElementById('is-reversed-data')?.textContent || 'false');
const isLoop = JSON.parse(document.getElementById('is-loop-data')?.textContent || 'false');
const derection = parseInt(document.getElementById('derection-data')?.textContent || '0');

// 创建站点节点HTML
function createStationNode(station) {
    const isNext = station.station_name === nextStationName;
    const isTransfer = station.is_transfer;
    const isInactive = fullRouteMode && !currentRouteSet.has(station.station_name);
    
    return `
        <div class="station-node">
            <div class="station-circle ${isNext ? 'next' : ''} ${isTransfer ? 'transfer' : ''} ${isInactive ? 'inactive' : ''}"></div>
            ${station.transfer_badges && station.transfer_badges.length > 0 ? `
                <div class="transfer-badges">
                    ${station.transfer_badges.map(b => `
                        <div class="transfer-badge ${String(b.code).length > 1 ? 'wide' : ''}" data-color="${b.color}">${b.code}</div>
                    `).join('')}
                </div>
            ` : ''}
            <div class="station-labels">
                <div class="station-name ${isNext ? 'current' : ''} ${isInactive ? 'inactive' : ''}">${station.station_name}</div>
                <div class="station-name en ${isInactive ? 'inactive' : ''}">${station.station_en_name || station.station_name_en || ''}</div>
            </div>
            ${isNext ? `
                
            ` : ''}
        </div>
    `;
}

// 计算每行能容纳的站点数量
function calculateStationsPerRow() {
    const container = document.querySelector('.line-map-container');
    // 更稳健的宽度测量，避免初次渲染方向切换导致的宽度偏差
    const containerWidth = Math.floor(container.getBoundingClientRect().width || container.clientWidth || container.offsetWidth || 0);
    const stationWidth = 40; // 站点节点宽度
    const stationSpacingMultiplier = parseFloat('{{ station_spacing_multiplier }}') || 1.0; // 获取倍数，默认为1.0
    const gap = 25 * stationSpacingMultiplier; // 站点间距，乘以倍数
    const margin = 40; // 边距
    
    const availableWidth = Math.max(0, containerWidth - margin * 2);
    // 修正计算公式：N个站点需要N-1个间距，公式为 N*w + (N-1)*g <= W => N*(w+g) - g <= W => N <= (W+g)/(w+g)
    const stationsPerRow = Math.floor((availableWidth + gap) / (stationWidth + gap));
    
    return Math.max(1, stationsPerRow);
}

// 创建Z字形布局
function createZigzagLayout() {
    const metroLine = document.getElementById('metro-line');
    const stationsPerRow = calculateStationsPerRow();

    // 计算满行时的动态间距，用于给不满的行设置相同的间距
    const container = document.querySelector('.line-map-container');
    const containerWidth = Math.floor(container.getBoundingClientRect().width || container.clientWidth || container.offsetWidth || 0);
    const margin = 40;
    const availableWidth = Math.max(0, containerWidth - margin * 2);
    const stationWidth = 40;
    // 如果只有1列，gap无意义；否则计算均匀分布后的实际gap
    const stationSpacingMultiplier = parseFloat('{{ station_spacing_multiplier }}') || 1.0; // 获取倍数，默认为1.0
    let dynamicGap = 25 * stationSpacingMultiplier; 
    if (stationsPerRow > 1) {
        dynamicGap = (availableWidth - stationsPerRow * stationWidth) / (stationsPerRow - 1);
    }

    // 计算全局“下一站”索引并存入容器数据属性
    const globalNextIndex = lineInfo.findIndex(s => s.station_name === nextStationName);
    metroLine.dataset.nextIndex = String(globalNextIndex);
    
    // 清空现有内容
    metroLine.innerHTML = '';
    
    // 如果站点数量少于每行容量，直接显示一行
    if (lineInfo.length <= stationsPerRow) {
        const row = document.createElement('div');
        row.className = 'line-row';
        // 记录单行范围
        row.dataset.startIndex = '0';
        row.dataset.endIndex = String(lineInfo.length - 1);
        row.innerHTML = lineInfo.map(createStationNode).join('');
        metroLine.appendChild(row);
        return;
    }
    
    // 创建多行Z字形布局
    let currentIndex = 0;
    let rowIndex = 0;
    
    console.log(`总站点数: ${lineInfo.length}, 每行站点数: ${stationsPerRow}`);
    
    while (currentIndex < lineInfo.length) {
        const row = document.createElement('div');
        // 修正：行索引为奇数的行翻转（第2、4、6...行）
        const isReverse = rowIndex % 2 === 1; // 行索引从0开始，奇数索引对应偶数行
        row.className = `line-row ${isReverse ? 'reverse' : ''}`;
        
        // 计算当前行的站点范围
        const startIndex = currentIndex;
        const endIndex = Math.min(currentIndex + stationsPerRow, lineInfo.length);
        const rowStations = lineInfo.slice(startIndex, endIndex);

        // 如果该行不满（通常是最后一行），改用 flex-start 并设置 calculated gap
        if (rowStations.length < stationsPerRow) {
            row.style.justifyContent = 'flex-start';
            row.style.gap = `${dynamicGap}px`;
        }
        
        // 记录该行的索引范围（闭区间）
        row.dataset.startIndex = String(startIndex);
        row.dataset.endIndex = String(endIndex - 1);
        
        console.log(`第${rowIndex + 1}行 (索引${rowIndex}): ${isReverse ? '反向' : '正向'}, 站点: ${startIndex + 1}-${endIndex}`);
        if (isReverse) {
            console.log(`  反向行（CSS反排）: ${rowStations.map(s => s.station_name).join(' → ')}`);
        }
        
        row.innerHTML = rowStations.map(createStationNode).join('');
        metroLine.appendChild(row);
        
        // 连接线改由计算阶段基于实际位置添加，这里不再创建
        
        currentIndex = endIndex;
        rowIndex++;
    }
}

// 计算轨道和连接线
function computeRailAndConnectors() {
    const metroLine = document.getElementById('metro-line');
    const metroRect = metroLine.getBoundingClientRect();
    const thickness = 15; // 轨道厚度，与CSS保持一致
    const metroWidth = Math.floor(metroRect.width || metroLine.clientWidth || metroLine.offsetWidth || 0);

    const rows = Array.from(document.querySelectorAll('.line-row'));

    // 清理旧连接线和旧箭头
    metroLine.querySelectorAll('.connector').forEach(el => el.remove());
    metroLine.querySelectorAll('.direction-arrow').forEach(el => el.remove());
    
    // 先计算每行的轨道（灰色与彩色段）
    rows.forEach((row, rowIndex) => {
        const stations = Array.from(row.querySelectorAll('.station-node'));
        
        const rowLeft = row.getBoundingClientRect().left;
        
        if (stations.length < 2) {
            // 单站点行：不显示轨道
            row.style.setProperty('--rail-left', '0px');
            row.style.setProperty('--rail-width', '0px');
            row.style.setProperty('--rail-colored-left', '0px');
            row.style.setProperty('--rail-colored-width', '0px');
            return;
        }
        
        const firstRect = stations[0].getBoundingClientRect();
        const lastRect = stations[stations.length - 1].getBoundingClientRect();
        
        const firstCenterX = firstRect.left + firstRect.width / 2;
        const lastCenterX = lastRect.left + lastRect.width / 2;
        
        // 轨道起止点对齐站点圆心，避免在端侧突出
        const railLeft = Math.min(firstCenterX, lastCenterX) - rowLeft;
        const railWidth = Math.abs(lastCenterX - firstCenterX);
        
        // 左侧越界保护，避免负 left 导致轨道起点在容器外
        row.style.setProperty('--rail-left', Math.max(0, railLeft) + 'px');
        row.style.setProperty('--rail-width', railWidth + 'px');

        // 根据全局“下一站”索引判断整行着色逻辑
        const globalNextIndex = parseInt(document.getElementById('metro-line').dataset.nextIndex || '-1');
        const rowStart = parseInt(row.dataset.startIndex || '-1');
        const rowEnd = parseInt(row.dataset.endIndex || '-1');

        let coloredLeft = Math.max(0, railLeft);
        let coloredWidth = 0;

        // 计算当前子路线的全局活动区间（activeStart..activeEnd）
        const activeIndices = currentRouteStations.length ? lineInfo.map((s, i) => currentRouteSet.has(s.station_name) ? i : -1).filter(i => i >= 0) : [];
        const activeStart = activeIndices.length ? Math.min(...activeIndices) : -1;
        const activeEnd = activeIndices.length ? Math.max(...activeIndices) : -1;
        const hasActiveRange = fullRouteMode && activeStart >= 0 && activeEnd >= 0;
        
        if (!isNaN(globalNextIndex) && !isNaN(rowStart) && !isNaN(rowEnd)) {
            if (globalNextIndex >= rowStart && globalNextIndex <= rowEnd) {
                // 下一站在本行：从下一站到活动区间端点（或行端）着色
                const localNextIndex = stations.findIndex(station => 
                    station.querySelector('.station-circle').classList.contains('next')
                );
                // 已走过标记：方向不依赖视觉反排，统一按“下一站之前”为已走过
                const isReverseRow = row.classList.contains('reverse');
                stations.forEach((station, idx) => {
                    const globalIdx = rowStart + idx;
                    const circle = station.querySelector('.station-circle');
                    const isActive = !hasActiveRange ? true : (globalIdx >= activeStart && globalIdx <= activeEnd);
                    if (isActive && localNextIndex >= 0) {
                        const isPassed = idx < localNextIndex; // 修正：反转行也按索引小于下一站为已走过
                        if (isPassed) {
                            circle.classList.add('passed');
                        }
                    }
                });
                if (localNextIndex >= 0) {
                    const nextRect = stations[localNextIndex].getBoundingClientRect();
                    const nextCenterX = nextRect.left + nextRect.width / 2;
                    let endIndexForColor;
                    if (hasActiveRange) {
                        const rowActiveStart = Math.max(rowStart, activeStart);
                        const rowActiveEnd = Math.min(rowEnd, activeEnd);
                        if (rowActiveStart <= rowActiveEnd) {
                            // 修正：未走过段应从下一站延伸到行的“末端”（活动区间内的较大索引），与视觉反排无关
                            endIndexForColor = (rowActiveEnd - rowStart);
                        }
                    }
                    if (endIndexForColor === undefined) {
                        // 未走过段（无活动区间）统一延伸到行末端（较大索引）
                        endIndexForColor = stations.length - 1;
                    }
                    const endRect = stations[endIndexForColor].getBoundingClientRect();
                    const endCenterX = endRect.left + endRect.width / 2;
                    coloredLeft = Math.min(nextCenterX, endCenterX) - rowLeft;
                    coloredWidth = Math.abs(endCenterX - nextCenterX);
                }
            } else if (globalNextIndex < rowStart) {
                // 下一站在本行之前：本行尚未到达，若存在活动区间，仅着色活动区间部分
                if (hasActiveRange) {
                    const rowActiveStart = Math.max(rowStart, activeStart);
                    const rowActiveEnd = Math.min(rowEnd, activeEnd);
                    if (rowActiveStart <= rowActiveEnd) {
                        const startRect = stations[rowActiveStart - rowStart].getBoundingClientRect();
                        const endRect = stations[rowActiveEnd - rowStart].getBoundingClientRect();
                        const startX = startRect.left + startRect.width / 2;
                        const endX = endRect.left + endRect.width / 2;
                        coloredLeft = Math.min(startX, endX) - rowLeft;
                        coloredWidth = Math.abs(endX - startX);
                    } else {
                        coloredLeft = Math.max(0, railLeft);
                        coloredWidth = 0;
                    }
                } else {
                    coloredLeft = Math.max(0, railLeft);
                    coloredWidth = railWidth;
                }
            } else {
                // 下一站在本行之后：本行已全部经过，仅将活动区间站标记为已过
                coloredLeft = Math.max(0, railLeft);
                coloredWidth = 0;
                stations.forEach((station, idx) => {
                    const globalIdx = rowStart + idx;
                    const circle = station.querySelector('.station-circle');
                    const isActive = !hasActiveRange ? true : (globalIdx >= activeStart && globalIdx <= activeEnd);
                    if (isActive) circle.classList.add('passed');
                });
            }
        }
        
        // 左侧越界保护，避免彩色段起点在容器外
        row.style.setProperty('--rail-colored-left', Math.max(0, coloredLeft) + 'px');
        row.style.setProperty('--rail-colored-width', coloredWidth + 'px');

        // 为本行每个水平线段添加方向箭头（不处理换行处横线）
        const isReverseRow = row.classList.contains('reverse');
        const rowCenterY = row.getBoundingClientRect().height / 2;
        for (let seg = 0; seg < stations.length - 1; seg++) {
            const aRect = stations[seg].getBoundingClientRect();
            const bRect = stations[seg + 1].getBoundingClientRect();
            const aX = aRect.left + aRect.width / 2;
            const bX = bRect.left + bRect.width / 2;
            let midX = (aX + bX) / 2 - row.getBoundingClientRect().left;
            // 左侧越界保护，保证箭头不会在行容器外
            midX = Math.max(0, Math.min(row.getBoundingClientRect().width, midX));
            const arrow = document.createElement('div');
            
            const rowStartIndex = parseInt(row.dataset.startIndex || '-1');
            const globalNextIndex = parseInt(document.getElementById('metro-line').dataset.nextIndex || '-1');
            const laterIndex = (isNaN(rowStartIndex) ? (seg + 1) : (rowStartIndex + seg + 1));

            // 仅在活动区间内绘制箭头；活动外的线段保持静止且不显示箭头
            let activeStartIdx = -1, activeEndIdx = -1;
            if (fullRouteMode) {
                const activeIndices = currentRouteStations.length ? lineInfo.map((s, i) => currentRouteSet.has(s.station_name) ? i : -1).filter(i => i >= 0) : [];
                activeStartIdx = activeIndices.length ? Math.min(...activeIndices) : -1;
                activeEndIdx = activeIndices.length ? Math.max(...activeIndices) : -1;
            }
            const segAIdx = isNaN(rowStartIndex) ? seg : (rowStartIndex + seg);
            const segBIdx = segAIdx + 1;
            if (fullRouteMode && !(segAIdx >= activeStartIdx && segAIdx <= activeEndIdx) && !(segBIdx >= activeStartIdx && segBIdx <= activeEndIdx)) {
                continue;
            }

            let colorClass = 'black';
            if (!isNaN(globalNextIndex) && !isNaN(laterIndex)) {
                if (laterIndex < globalNextIndex) colorClass = 'gray';
                else if (laterIndex === globalNextIndex) colorClass = 'red';
            }
            
            arrow.className = 'direction-arrow ' + colorClass;
            arrow.textContent = isReverseRow ? '←' : '→';
            arrow.style.left = midX + 'px';
            arrow.style.top = rowCenterY + 'px';
            arrow.style.transform = 'translate(-50%, -50%)';
            row.appendChild(arrow);
        }
    });

    // connector cap style moved to CSS <style> block
    
    // 计算全局活动区间（用于连接线灰显判断）
    let activeStartIdx = -1, activeEndIdx = -1;
    if (fullRouteMode) {
        const activeIndices = currentRouteStations.length ? lineInfo.map((s, i) => currentRouteSet.has(s.station_name) ? i : -1).filter(i => i >= 0) : [];
        activeStartIdx = activeIndices.length ? Math.min(...activeIndices) : -1;
        activeEndIdx = activeIndices.length ? Math.max(...activeIndices) : -1;
    }

    // 再绘制每两行之间的平滑垂直连接
    for (let i = 0; i < rows.length - 1; i++) {
        const upper = rows[i];
        const lower = rows[i + 1];
        const upperStations = Array.from(upper.querySelectorAll('.station-node'));
        const lowerStations = Array.from(lower.querySelectorAll('.station-node'));
        if (upperStations.length === 0 || lowerStations.length === 0) continue;
        
        // 连接侧：偶数索引行（第1、3...）连接右侧，奇数索引行连接左侧
        const side = i % 2 === 0 ? 'right' : 'left';
        const sgn = side === 'right' ? 1 : -1;
        const outward = 35; // 向外偏移以美化转角
        
        function endpointX(row, stations, side) {
            let rect;
            if (side === 'right') {
                rect = row.classList.contains('reverse') ? stations[0].getBoundingClientRect() : stations[stations.length - 1].getBoundingClientRect();
            } else { // left
                rect = row.classList.contains('reverse') ? stations[stations.length - 1].getBoundingClientRect() : stations[0].getBoundingClientRect();
            }
            return rect.left + rect.width / 2 - metroRect.left;
        }
        
        const xUpper = endpointX(upper, upperStations, side);
        const xLower = endpointX(lower, lowerStations, side);
        const yUpper = upper.getBoundingClientRect().top + upper.getBoundingClientRect().height / 2 - metroRect.top;
        const yLower = lower.getBoundingClientRect().top + lower.getBoundingClientRect().height / 2 - metroRect.top;
        
        // 竖直线外移到行端外侧
        const xOut = xUpper + sgn * outward;
        
        // 颜色逻辑：仅在连接线位于当前子路线活动区间内时才着色；并结合“下一站”位置控制是否为未经过（主题色）
        const themeColor = getComputedStyle(metroLine).getPropertyValue('--theme-color').trim() || '#9b5de5';
        const globalNextIndex = parseInt(metroLine.dataset.nextIndex || '-1');
        const upperStartIndex = parseInt(upper.dataset.startIndex || '-1');
        const upperEndIndex = parseInt(upper.dataset.endIndex || '-1');
        const lowerStartIndex = parseInt(lower.dataset.startIndex || '-1');
        const lowerEndIndex = parseInt(lower.dataset.endIndex || '-1');
        function endpointGlobalIndex(rowEl, sideSel, startIdx, endIdx) {
            const isRev = rowEl.classList.contains('reverse');
            if (sideSel === 'right') {
                return isRev ? startIdx : endIdx;
            } else {
                return isRev ? endIdx : startIdx;
            }
        }
        const upIdx = endpointGlobalIndex(upper, side, upperStartIndex, upperEndIndex);
        const lowIdx = endpointGlobalIndex(lower, side, lowerStartIndex, lowerEndIndex);
        const connectorActive = !fullRouteMode ? true : (
            upIdx >= activeStartIdx && upIdx <= activeEndIdx &&
            lowIdx >= activeStartIdx && lowIdx <= activeEndIdx
        );
        const shouldColor = connectorActive && (!isNaN(globalNextIndex) && !isNaN(lowerStartIndex) && globalNextIndex < lowerStartIndex);
        
        // 避免亚像素缝隙：所有关键坐标取整，并结合左侧越界做保护
        const xUpperR = Math.round(xUpper);
        const xLowerR = Math.round(xLower);
        const yUpperR = Math.round(yUpper);
        const yLowerR = Math.round(yLower);
        let xOutR = Math.round(xOut);
        // 左边界保护，避免大外移或方向切换导致的负值
        const xOutRClamped = Math.max(thickness / 2, Math.min(metroWidth - thickness / 2, xOutR));
        
        // 顶部水平过渡段：从行端到外移位置（在圆弧帽下方额外延伸半个厚度以避免缝隙）
        const hTop = document.createElement('div');
        hTop.className = 'connector horizontal';
        hTop.style.position = 'absolute';
        // 顶部水平段：根据朝向决定延伸方向（右向：延伸到右；左向：延伸到左）
        let leftStartTop = Math.min(xUpperR, xOutRClamped);
        let rightEndTop = Math.max(xUpperR, xOutRClamped);
        if (sgn > 0) {
            rightEndTop += thickness / 2; // 朝右时，向右延伸覆盖圆弧帽
        } else {
            leftStartTop -= thickness / 2; // 朝左时，向左延伸覆盖圆弧帽
        }
        // 左边界保护
        leftStartTop = Math.max(0, leftStartTop);
        rightEndTop = Math.max(leftStartTop, Math.min(metroWidth, rightEndTop));
        hTop.style.left = leftStartTop + 'px';
        hTop.style.top = yUpperR + 'px';
        hTop.style.transform = 'translateY(-50%)';
        hTop.style.width = (rightEndTop - leftStartTop) + 'px';
        hTop.style.height = thickness + 'px';
        hTop.style.borderRadius = (thickness / 2) + 'px';
        hTop.style.zIndex = '1';
        if (shouldColor) hTop.style.backgroundColor = themeColor;
        metroLine.appendChild(hTop);
        
        // 顶部圆弧帽（尺寸随厚度、层级更高以覆盖接缝）
        const capTop = document.createElement('div');
        capTop.className = 'connector cap';
        capTop.style.left = (xOutRClamped - thickness / 2) + 'px';
        capTop.style.top = (yUpperR - thickness / 2) + 'px';
        capTop.style.width = thickness + 'px';
        capTop.style.height = thickness + 'px';
        capTop.style.zIndex = '2';
        if (shouldColor) capTop.style.backgroundColor = themeColor;
        metroLine.appendChild(capTop);
        
        // 垂直段：与两端圆弧帽重叠半径
        const v = document.createElement('div');
        v.className = 'connector vertical';
        v.style.position = 'absolute';
        v.style.left = (xOutRClamped - thickness / 2) + 'px';
        v.style.top = (yUpperR - thickness / 2) + 'px';
        v.style.height = (yLowerR - yUpperR + thickness) + 'px';
        v.style.width = thickness + 'px';
        v.style.transform = 'none';
        v.style.borderRadius = (thickness / 2) + 'px';
        v.style.zIndex = '1';
        if (shouldColor) v.style.backgroundColor = themeColor;
        metroLine.appendChild(v);
        
        // 竖直方向箭头（只在竖直段加），仅在活动区间内绘制
        if (connectorActive) {
            const arrowV = document.createElement('div');
            const lowerIsReverse = lower.classList.contains('reverse');
            let laterIndexV;
            if (side === 'right') {
                laterIndexV = lowerIsReverse ? lowerStartIndex : lowerEndIndex;
            } else {
                laterIndexV = lowerIsReverse ? lowerEndIndex : lowerStartIndex;
            }
            let colorClassV = 'black';
            if (!isNaN(globalNextIndex) && !isNaN(laterIndexV)) {
                if (laterIndexV < globalNextIndex) colorClassV = 'gray';
                else if (laterIndexV === globalNextIndex) colorClassV = 'red';
            }
            arrowV.className = 'direction-arrow ' + colorClassV;
            arrowV.textContent = '↓';
            arrowV.style.left = xOutRClamped + 'px';
            arrowV.style.top = Math.round((yUpperR + yLowerR) / 2) + 'px';
            arrowV.style.transform = 'translate(-50%, -50%)';
            metroLine.appendChild(arrowV);
        }
        
        // 底部圆弧帽（尺寸随厚度、层级更高以覆盖接缝）
        const capBottom = document.createElement('div');
        capBottom.className = 'connector cap';
        capBottom.style.left = (xOutRClamped - thickness / 2) + 'px';
        capBottom.style.top = (yLowerR - thickness / 2) + 'px';
        capBottom.style.width = thickness + 'px';
        capBottom.style.height = thickness + 'px';
        capBottom.style.zIndex = '2';
        if (shouldColor) capBottom.style.backgroundColor = themeColor;
        metroLine.appendChild(capBottom);
        
        // 底部水平过渡段：从外移位置回到下行端（在圆弧帽下方额外延伸半个厚度以避免缝隙）
        const hBottom = document.createElement('div');
        hBottom.className = 'connector horizontal';
        hBottom.style.position = 'absolute';
        // 底部水平段：根据朝向决定延伸方向
        // 规则：一端向外延伸覆盖圆弧帽，另一端向行内延伸覆盖行端圆角，确保双侧无缝
        let leftStartBottom = Math.min(xOutRClamped, xLowerR);
        let rightEndBottom = Math.max(xOutRClamped, xLowerR);
        if (sgn > 0) {
            // 右向：起点在左、终点在右
            leftStartBottom -= thickness / 2;   // 向左延伸覆盖底部圆弧帽
            rightEndBottom += thickness / 2;    // 向右延伸少量覆盖行端圆角
        } else {
            // 左向：起点在右、终点在左
            rightEndBottom += thickness / 2;    // 向右延伸覆盖底部圆弧帽
            leftStartBottom -= thickness / 2;   // 向左延伸少量覆盖行端圆角
        }
        // 左边界保护
        leftStartBottom = Math.max(0, leftStartBottom);
        rightEndBottom = Math.max(leftStartBottom, Math.min(metroWidth, rightEndBottom));
        hBottom.style.left = leftStartBottom + 'px';
        hBottom.style.top = yLowerR + 'px';
        hBottom.style.transform = 'translateY(-50%)';
        hBottom.style.width = (rightEndBottom - leftStartBottom) + 'px';
        hBottom.style.height = thickness + 'px';
        hBottom.style.borderRadius = (thickness / 2) + 'px';
        hBottom.style.zIndex = '1';
        if (shouldColor) hBottom.style.backgroundColor = themeColor;
        metroLine.appendChild(hBottom);
    }
}


// 设定徽章背景色
function setTransferBadgeColors() {
    document.querySelectorAll('.transfer-badge[data-color]').forEach(el => {
        const c = el.getAttribute('data-color');
        if (c) el.style.backgroundColor = c;
    });
}

// 为换乘站创建旋转多色环
function createTransferRings() {
    document.querySelectorAll('.station-node').forEach(node => {
        const circle = node.querySelector('.station-circle.transfer');
        if (!circle) return;
        
        const themeColor = getComputedStyle(circle).getPropertyValue('--theme-color').trim() || '#9b5de5';
        const badgeEls = node.querySelectorAll('.transfer-badge[data-color]');
        const colors = [themeColor];
        
        badgeEls.forEach(b => {
            const c = b.getAttribute('data-color');
            if (c) colors.push(c);
        });
        
        const share = 100 / colors.length;
        let start = 0;
        const parts = colors.map((clr) => {
            const end = start + share;
            const seg = `${clr} ${start}% ${end}%`;
            start = end;
            return seg;
        });
        
        const ring = document.createElement('span');
        ring.style.position = 'absolute';
        ring.style.inset = '-2px';
        ring.style.borderRadius = '50%';
        ring.style.background = `conic-gradient(${parts.join(', ')})`;
        ring.style.zIndex = '0';
        
        // 非当前子路线的换乘环保持静止；仅对活动且未经过的换乘站启用旋转
        const isInactive = circle.classList.contains('inactive');
        if (!circle.classList.contains('passed') && !isInactive) {
            ring.style.animation = 'spin 4s linear infinite';
        }
        
        circle.appendChild(ring);
    });
}

// 滚动到下一站
function scrollToNextStation() {
    const nextStation = document.querySelector('.station-node .station-circle.next');
    if (nextStation) {
        nextStation.closest('.station-node').scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center', 
            inline: 'nearest' // 避免水平滚动导致内容抖动与画布外定位
        });
    }
}

// 窗口大小变化时重新布局
function handleResize() {
    if (JSON.parse(document.getElementById('is-loop-data')?.textContent || 'false')) {
        renderLoopMap();
    } else {
        createZigzagLayout();
        computeRailAndConnectors();
        setTransferBadgeColors();
        createTransferRings();
    }
}

function init() {
    if (JSON.parse(document.getElementById('is-loop-data')?.textContent || 'false')) {
        renderLoopMap();
        // 注释掉自动滚动到下一站，让页面保持在最上方
        // scrollToNextStation();
        window.addEventListener('resize', handleResize);
    } else {
        createZigzagLayout();
        computeRailAndConnectors();
        setTransferBadgeColors();
        createTransferRings();
        // 注释掉自动滚动到下一站，让页面保持在最上方
        // scrollToNextStation();
        // 线性布局首次渲染后做一次延迟复测，修复 direction=1 时初次宽度与位置不稳定导致的左侧挤出
        const metroLine = document.getElementById('metro-line');
        if (metroLine && metroLine.dataset.settle !== 'done') {
            metroLine.dataset.settle = 'pending';
            requestAnimationFrame(() => {
                setTimeout(() => {
                    metroLine.dataset.settle = 'done';
                    createZigzagLayout();
                    computeRailAndConnectors();
                    setTransferBadgeColors();
                    createTransferRings();
                }, 60);
            });
        }
        window.addEventListener('resize', handleResize);
    }
}

function renderLoopMap() {
    const rl = document.getElementById('ring-line');
    const ml = document.getElementById('metro-line');
    if (!rl || !ml) return;
    rl.style.display = '';
    ml.style.display = 'none';
    rl.innerHTML = '';

    const container = document.querySelector('.line-map-container');
    const reserve = 160; // 为外侧标签和安全边留白，防止溢出
    const minWidth = 680; // 缩小最小宽度
    // 使用更稳定的尺寸测量，避免初次渲染因容器状态或滚动条导致偏差
    const containerRectWidth = Math.floor(container.getBoundingClientRect().width || container.clientWidth || container.offsetWidth || 0);
    const width = Math.max(minWidth, containerRectWidth - reserve);
    const height = Math.max(320, Math.min(520, Math.round(width * 0.45)));
    const margin = 40;
    const W = width - margin * 2;
    const H = height - margin * 2;
    const radius = Math.round(Math.min(W, H) * 0.12);
    const ns = 'http://www.w3.org/2000/svg';

     const svg = document.createElementNS(ns, 'svg');
     svg.setAttribute('width', String(width));
     svg.setAttribute('height', String(height));
     svg.style.display = 'block';
     // 让环线容器成为定位上下文，并设置固定尺寸
     rl.style.position = 'relative';
    rl.style.margin = '0 auto'; // 居中，避免贴边
    rl.style.width = `${width}px`;
    rl.style.height = `${height}px`;
    // 让SVG与站点层叠在同一平面，SVG在下、站点在上
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.zIndex = '0';

    const base = document.createElementNS(ns, 'rect');
    base.setAttribute('x', String(margin));
    base.setAttribute('y', String(margin));
    base.setAttribute('width', String(W));
    base.setAttribute('height', String(H));
    base.setAttribute('rx', String(radius));
    base.setAttribute('ry', String(radius));
    base.setAttribute('fill', 'none');
    base.setAttribute('stroke', '#ddd');
    base.setAttribute('stroke-width', '15');
    svg.appendChild(base);

    const group = document.createElement('div');
    group.style.position = 'absolute';
    group.style.left = '0';
    group.style.top = '0';
    group.style.width = `${width}px`;
    group.style.height = `${height}px`;
    group.style.zIndex = '1';
    rl.appendChild(svg);
    rl.appendChild(group);

    const totalLen = (base.getTotalLength && base.getTotalLength()) || (2 * (W + H));
    const n = lineInfo.length;
    const nextIndex = lineInfo.findIndex(s => s.station_name === nextStationName);

    // 根据站点编号重排：将编号'01'锚定到顶边中点，其余按逆时针一周布局（并去重避免重复首尾站）
    const getStationNum = (s) => {
        const idx = s.station_index;
        if (Array.isArray(idx)) {
            const v = idx[idx.length - 1];
            const m = String(v || '').match(/^\d+$/);
            return m ? parseInt(v, 10) : NaN;
        } else {
            const m = String(idx || '').match(/^\d+$/);
            return m ? parseInt(idx, 10) : NaN;
        }
    };
    const entries = lineInfo.map((s, i) => ({ s, i, num: getStationNum(s) }));
    entries.sort((A, B) => {
        const a = isNaN(A.num) ? Number.MAX_SAFE_INTEGER : A.num;
        const b = isNaN(B.num) ? Number.MAX_SAFE_INTEGER : B.num;
        return a - b;
    });
    const ordered = entries.map(e => e.s);
    // 去重：以站名为键，保留首个出现的站
    const seen = new Set();
    const orderedUnique = [];
    for (const s of ordered) {
        const key = s.station_name || JSON.stringify(s.station_index);
        if (seen.has(key)) continue;
        seen.add(key);
        orderedUnique.push(s);
    }
    const nU = orderedUnique.length;
    const anchorPos = orderedUnique.findIndex(s => getStationNum(s) === 1);
    const seg = totalLen / nU;
    const anchorOffset = (W - 2 * radius) / 2; // 顶边直线段的中点
    const pts = [];
    const nodes = [];
    const dPos = [];

    for (let i = 0; i < nU; i++) {
        const stepsFromAnchor = ((i - (anchorPos >= 0 ? anchorPos : 0)) % nU + nU) % nU;
        const d = (anchorOffset - seg * stepsFromAnchor + totalLen) % totalLen; // 逆时针：长度递减
        const pt = (base.getPointAtLength ? base.getPointAtLength(d) : { x: margin + W / 2, y: margin });
        pts.push(pt);
        const tmp = document.createElement('div');
        tmp.innerHTML = createStationNode(orderedUnique[i]);
        const node = tmp.firstElementChild;
        node.style.position = 'absolute';
        node.style.left = `${pt.x}px`;
        node.style.top = `${pt.y}px`;
        node.style.transform = 'translate(-50%, -50%)';
        // 站名外侧，换乘内侧（按所在边）
        // 侧边特殊处理：用户要求侧边站点“文字左下对齐站点，站点左侧水平排列换乘数字”
        // 顶/底边保持默认CSS样式（文字上偏右，换乘下垂直）
        const labels = node.querySelector('.station-labels');
        const badges = node.querySelector('.transfer-badges');
        const tol = 20;
        
        // 判断是否在左右侧边（垂直段）
        const isLeft = Math.abs(pt.x - margin) < tol;
        const isRight = Math.abs(pt.x - (margin + W)) < tol;
        
        if (isLeft) {
            if (labels) {
                labels.style.left = '-100%'; // 站点左侧
                labels.style.bottom = '-500%'; // 站点上方
            }
            if (badges) {
                badges.style.top = '50%';
                badges.style.bottom = 'auto';
                badges.style.left = '30px'; // 距离左边界38px
                badges.style.right = 'auto';
                badges.style.transform = 'translateY(-50%)';
                badges.style.flexDirection = 'row';
                badges.style.gap = '2px';
            }
        } else if (isRight) {
            if (labels) {
                labels.style.left = '120%'; // 站点右侧
                labels.style.bottom = '0%'; // 站点上方
            }
            if (badges) {
                badges.style.top = '50%';
                badges.style.bottom = 'auto';
                badges.style.left = 'auto';
                badges.style.right = '30px'; 
                badges.style.transform = 'translateY(-50%)';
                badges.style.flexDirection = 'row';
                badges.style.gap = '2px';
            }
        }
        // 静态线路图：不做已过站灰显
        group.appendChild(node);
        nodes.push(node);
        dPos.push(d);
    }

    // 边段方向箭头：拐角处不显示（derection=0逆时针，derection=1顺时针）
    for (let i = 0; i < nU; i++) {
        const pA = pts[i];
        const pB = pts[(derection === 0 ? (i + 1) : (i - 1 + nU)) % nU];
        const midX = (pA.x + pB.x) / 2;
        const midY = (pA.y + pB.y) / 2;
        const dx = pB.x - pA.x;
        const dy = pB.y - pA.y;
        const inTopLeft = (x, y) => (x >= margin && x <= margin + radius) && (y >= margin && y <= margin + radius);
        const inTopRight = (x, y) => (x >= margin + W - radius && x <= margin + W) && (y >= margin && y <= margin + radius);
        const inBottomRight = (x, y) => (x >= margin + W - radius && x <= margin + W) && (y >= margin + H - radius && y <= margin + H);
        const inBottomLeft = (x, y) => (x >= margin && x <= margin + radius) && (y >= margin + H - radius && y <= margin + H);
        const nearCorner = (x, y) => inTopLeft(x, y) || inTopRight(x, y) || inBottomRight(x, y) || inBottomLeft(x, y);
        if (nearCorner(midX, midY) || nearCorner(pA.x, pA.y) || nearCorner(pB.x, pB.y)) {
            continue;
        }
        const arrow = document.createElement('div');
        arrow.className = 'direction-arrow black';
        let ch;
        if (Math.abs(dx) >= Math.abs(dy)) {
            ch = dx > 0 ? '→' : '←';
        } else {
            ch = dy > 0 ? '↓' : '↑';
        }
        arrow.textContent = ch;
        arrow.style.position = 'absolute';
        arrow.style.left = `${midX}px`;
        arrow.style.top = `${midY}px`;
        arrow.style.transform = 'translate(-50%, -50%)';
        group.appendChild(arrow);
    }

    // 颜色叠加：静态主题色整环（移除灰段与“已过站”标记）
    const themeColor = getComputedStyle(document.querySelector('.line-map')).getPropertyValue('--theme-color').trim() || '#9b5de5';
    const colored = document.createElementNS(ns, 'rect');
    colored.setAttribute('x', String(margin));
    colored.setAttribute('y', String(margin));
    colored.setAttribute('width', String(W));
    colored.setAttribute('height', String(H));
    colored.setAttribute('rx', String(radius));
    colored.setAttribute('ry', String(radius));
    colored.setAttribute('fill', 'none');
    colored.setAttribute('stroke', themeColor);
    colored.setAttribute('stroke-width', '15');
    svg.appendChild(colored);

    // 环线“已走过”规则：根据是否有终点站与方向标记灰段与站点
    (function applyLoopPassed() {
        const nextIdxU = orderedUnique.findIndex(s => s.station_name === nextStationName);
        const hasTerminal = JSON.parse(document.getElementById('loop-has-terminal-data')?.textContent || 'false');
        const terminalName = JSON.parse(document.getElementById('loop-terminal-station-data')?.textContent || 'null');
        const terminalIdxU = orderedUnique.findIndex(s => s.station_name === terminalName);
        if (nextIdxU < 0) return; // 无下一站，跳过

        // 方向：derection=0 按 i+1 前进；derection=1 按 i-1 前进
        const stepNext = (i) => (derection === 0 ? (i + 1) % nU : (i - 1 + nU) % nU);
        const stepPrev = (i) => (derection === 0 ? (i - 1 + nU) % nU : (i + 1) % nU);

        // 站点灰显列表
        let passedIndices = [];
        let startIdxForArc = -1;
        if (hasTerminal && terminalIdxU >= 0) {
            // 有终点站：从终点站到下一站（不含下一站）之间标记为已过
            let i = terminalIdxU;
            startIdxForArc = terminalIdxU;
            while (i !== nextIdxU) {
                if (i !== terminalIdxU) {
                    passedIndices.push(i);
                }
                i = stepNext(i);
            }
        } else {
            // 无终点站：仅上一站标记为已过，灰线覆盖上一站到下一站之间的段
            const prevIdxU = stepPrev(nextIdxU);
            passedIndices.push(prevIdxU);
            startIdxForArc = prevIdxU;
        }

        // 标记站点为已过（灰、静止）
        passedIndices.forEach(i => {
            const circle = nodes[i]?.querySelector('.station-circle');
            if (circle) circle.classList.add('passed');
        });

        // 绘制灰色已过线段：从起点到下一站的路径段（按路径增长方向从 endD 到 startD）
        if (startIdxForArc >= 0 && startIdxForArc !== nextIdxU) {
            const startD = dPos[startIdxForArc];
            const endD = dPos[nextIdxU];
            let L, startArcPos;
            if (derection === 0) {
                // 逆时针：沿站序 i+1 前进，d 随前进减小；灰段应从 endD 起，长度为 startD->endD 的差值
                L = (startD - endD + totalLen) % totalLen;
                startArcPos = endD;
            } else {
                // 顺时针：沿站序 i-1 前进，d 随前进增大；灰段应从 startD 起，长度为 startD->endD 的差值
                L = (endD - startD + totalLen) % totalLen;
                startArcPos = startD;
            }
            if (L > 0) {
                 const passedStroke = document.createElementNS(ns, 'rect');
                 passedStroke.setAttribute('x', String(margin));
                 passedStroke.setAttribute('y', String(margin));
                 passedStroke.setAttribute('width', String(W));
                 passedStroke.setAttribute('height', String(H));
                 passedStroke.setAttribute('rx', String(radius));
                 passedStroke.setAttribute('ry', String(radius));
                 passedStroke.setAttribute('fill', 'none');
                 passedStroke.setAttribute('stroke', '#cfcfcf');
                 passedStroke.setAttribute('stroke-width', '15');
                 passedStroke.setAttribute('stroke-linecap', 'butt');
                 // 单段灰：灰段长度 L，剩余为透明（总长 - L）
                 passedStroke.setAttribute('stroke-dasharray', `${L} ${totalLen - L}`);
                 // 从正确的起点开始绘制（随方向）
                 passedStroke.setAttribute('stroke-dashoffset', String((totalLen - startArcPos) % totalLen));
                 svg.appendChild(passedStroke);
             }
        }
    })();

    // 补充换乘徽章颜色与旋转环（保留）
    setTransferBadgeColors();
    createTransferRings();

    // 首次渲染后做一次延迟复测，避免初次布局时宽度尚未稳定导致两侧溢出
    if (rl && rl.dataset.settle !== 'done') {
        rl.dataset.settle = 'pending';
        requestAnimationFrame(() => {
            setTimeout(() => {
                rl.dataset.settle = 'done';
                renderLoopMap();
            }, 60);
        });
    }
}

document.addEventListener('DOMContentLoaded', init);
</script>
{% endblock %}