{% extends 'base.html' %}

{% block title %}线路图{% endblock %}

{% block header_subtitle %}
{% if is_loop %}
    {% set ring_label = '内环运行' if direction|int == 1 else '外环运行' %}
    {% if loop_has_terminal and loop_terminal_station %}
        {{ ring_label }} 终点站：<strong>{{ loop_terminal_station }}</strong>
        <div class="line-sub-info-en">{% if direction|int == 1 %}Inner Loop{% else %}Outer Loop{% endif %} Terminal: <strong>{{ trans_data.get(loop_terminal_station, loop_terminal_station).replace('<br>', ' ') }}</strong></div>
    {% else %}
        <strong>{{ ring_label }}</strong>
        <div class="line-sub-info-en">{% if direction|int == 1 %}Inner Loop{% else %}Outer Loop{% endif %}</div>
    {% endif %}
{% else %}
    {% set terminal_station_for_dir = '' %}
    {% if current_route_stations and current_route_stations|length > 0 %}
        {% if direction|int == 0 %}
            {% set terminal_station_for_dir = current_route_stations[-1] %}
        {% else %}
            {% set terminal_station_for_dir = current_route_stations[0] %}
        {% endif %}
    {% elif line_info and line_info|length > 0 %}
        {% set terminal_station_for_dir = (line_info[-1].station_name if direction|int == 0 else line_info[0].station_name) %}
    {% endif %}
    终点站：<strong>{{ terminal_station_for_dir }}</strong>
    <div class="line-sub-info-en">Terminal: <strong>{{ trans_data.get(terminal_station_for_dir, terminal_station_for_dir).replace('<br>', ' ') }}</strong></div>
{% endif %}
{% endblock %}

{% block page_title %}
    <div class="next-station-title">
        <div class="next-topline">
            <span class="next-station-label">下一站</span>
            <span class="next-station-label" style="font-size: 12px;">Next Station</span>
            {% if transfer_badges and transfer_badges|length > 0 %}
            <div class="next-station-transfers">
                <span class="transfer-label">换乘</span>
                <span class="transfer-label" style="font-size: 13px;">Transfer</span>
                <span class="next-transfer-badges">
                    {% for b in transfer_badges %}
                    <span class="transfer-badge {% if b.code|string|length > 1 %}wide{% endif %}" data-color="{{ b.color }}">{{ b.code }}</span>
                    {% endfor %}
                </span>
            </div>
            {% endif %}
        </div>
        <span class="next-station-name">{{ next_station }}</span>
        <span class="next-station-name-en">{{ trans_data.get(next_station, next_station).replace('<br>', ' ') }}</span>
    </div>
{% endblock %}

{% block head %}
<style>
    .next-station-title {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
    }
    .next-topline { display: inline-flex; align-items: center; gap: 10px; }
    .next-station-label {
        font-size: 18px;
        color: #fff;
        opacity: 0.9;
    }
    .transfer-label { font-size: 18px; color: #fff; opacity: 0.9; font-weight: normal; }
    .next-station-name {
        font-size: 32px;
        font-weight: bold;
        color: #fff;
    }
    .next-station-name-en {
        font-size: 16px;
        color: #fff;
        opacity: 0.8;
    }
    .next-station-transfers {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: #fff;
        opacity: 0.9;
        margin-top: 0; /* 与“下一站”同行显示，不用上边距 */
    }
    .next-transfer-badges { display: inline-flex; gap: 6px; }
    .transfer-badge { width: 22px; height: 22px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 12px; color: white; font-weight: bold; }
    
    .line-map-container {
        width: 100%;
        padding: 60px 0; /* 增大顶部间距 */
        min-height: 75vh; /* 增加画布高度：可根据需要调整比例 */
        overflow: hidden; /* 保证内容不超出白色画布 */
    }
    
    .line-map {
        position: relative;
        width: 100%;
    }
    
    .metro-line {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-start;
        gap: 25px;
        margin-top: 80px;
        margin-bottom: 40px;
        position: relative;
        width: 100%;
        padding: 0 40px;
    }
    
    .line-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 25px;
        position: relative;
        width: 100%;
        margin-bottom: 100px;
    }
    
    .line-row:last-child {
        margin-bottom: 0;
    }
    
    /* 反向行（偶数行） */
    .line-row.reverse {
        flex-direction: row-reverse;
        justify-content: space-between;
    }
    
    :root {
        --theme-color: #9b5de5;
        /* 箭头配置 */
        --arrow-size: 25px;
        --arrow-weight: 900;
        --arrow-color-black: #000;
        --arrow-color-gray: #555;
        --arrow-color-red: #ff3b30;
        --arrow-blink-duration: 1s;
        --one-label-offset: 8px;
        --one-badge-offset: 4px;
        --two-label-offset: 6px;
        --two-badge-offset: 4px;
        --two-label-angle: -45deg;
    }
    /* 基础灰色轨道（已走过段） */
    .line-row::after {
        content: '';
        position: absolute;
        top: 50%;
        left: var(--rail-left, 0);
        right: var(--rail-right, auto);
        width: var(--rail-width, 100%);
        height: 15px;
        background-color: #ddd;
        transform: translateY(-50%);
        border-radius: 8px;
        z-index: 0;
    }
    /* 彩色未走过轨道段（从下一站开始） */
    .line-row::before {
        content: '';
        position: absolute;
        top: 50%;
        left: var(--rail-colored-left, var(--rail-left, 0));
        right: var(--rail-colored-right, var(--rail-right, auto));
        width: var(--rail-colored-width, 0);
        height: 15px;
        background-color: var(--theme-color);
        transform: translateY(-50%);
        border-radius: 8px;
        z-index: 1;
    }
    
    /* 连接线 - 行间连接 */
    .connector {
        position: absolute;
        background-color: #ddd;
        z-index: 0;
    }
    
    /* 垂直连接线 */
    .connector.vertical {
        width: 15px;
        height: var(--connector-height, 80px);
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 8px;
    }
    
    /* 水平连接线（用于反向行） */
    .connector.horizontal {
        width: var(--connector-width, 60px);
        height: 15px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 8px;
    }
    
    /* 方向箭头样式 */
    .direction-arrow {
        position: absolute;
        font-weight: var(--arrow-weight, 900);
        font-size: var(--arrow-size, 18px);
        line-height: 1;
        z-index: 1;
        pointer-events: none;
    }
    .direction-arrow.black { color: var(--arrow-color-black, #000); }
    .direction-arrow.gray { color: var(--arrow-color-gray, #555); }
    .direction-arrow.red { color: var(--arrow-color-red, #ff3b30); animation: blink var(--arrow-blink-duration, 1s) infinite alternate; }
    
    /* 圆弧帽（连接水平与垂直） */
    .connector.cap {
        width: 15px;
        height: 15px;
        position: absolute;
        background-color: #ddd;
        border-radius: 50%;
        z-index: 0;
    }
    
    .station-node {
        position: relative;
        z-index: 2;
        min-width: 40px;
        width: 40px;
        height: 10px;
    }
    
    .station-circle {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #fff;
        border: 3px solid var(--theme-color);
        color: #fff;
        box-shadow: 0 0 0 3px #fff inset;
    }
    
    /* 仅下一站显示红点动画 */
    .station-circle.next::before {
        content: '';
        width: 10px;
        height: 10px;
        background: #ff3b30;
        border-radius: 50%;
        animation: blink 1s infinite alternate;
    }

    /* 下一站英文名加粗且红色 */
    .station-circle.next ~ .station-labels .station-name.en {
        color: #ff4757;
        font-weight: bold;
    }
    
    /* 已走过站点：灰色且无动态 */
    .station-circle.passed {
        background-color: #cfcfcf;
        border-color: #cfcfcf;
        box-shadow: 0 0 0 3px #cfcfcf inset;
    }

    /* 非当前子路线站点：灰色静止（不显示动画与彩环） */
    .station-circle.inactive {
        background-color: #eeeeee;
        border-color: #dddddd;
        box-shadow: 0 0 0 3px #eeeeee inset;
    }
    .station-name.inactive {
        color: #999999;
    }
    
    /* 换乘站：空心圆环，旋转彩环仅未走过时启用 */
    .station-circle.transfer {
        background-color: transparent;
        color: var(--theme-color);
        box-shadow: none;
        border: 4px solid var(--theme-color);
    }
    /* 非当前子路线的换乘站：环不旋转，边框改为中性灰，保持空心圆展示等分环 */
    .station-circle.transfer.inactive {
        background-color: transparent;
        border-color: #cccccc;
        box-shadow: none;
    }
    .station-circle.transfer::before {
        content: '';
        position: absolute;
        inset: 6px;
        border-radius: 50%;
        background: #fff;
        z-index: 1;
    }
    
    .station-labels {
        position: absolute;
        bottom: 25px;
        left: 50%;
        transform-origin: bottom left;
        transform: rotate(-45deg);
        text-align: left;
        width: 140px;
        display: flex;
        flex-direction: column-reverse;
        pointer-events: none;
    }
    .station-name {
        font-size: 13px;
        color: #333;
        text-align: left;
        line-height: 1.2;
        white-space: nowrap;
        font-weight: bold;
    }
    .station-name.current {
        color: #ff4757;
        font-weight: bold;
    }
    .station-name.en {
        font-size: 10px;
        color: #666;
        margin-top: 2px;
    }

    /* 岔路连接线 */
    .branch-connector {
        position: absolute;
        z-index: 0;
        transform-origin: 0 50%;
    }

    /* 岔路行样式 */
    .branch-row {
        /* 确保无额外边框 */
        border: none !important; 
    }
    
    /* 未激活的岔路行：隐藏彩色进度条 */
    .branch-row.inactive-row::before {
        width: 0 !important;
        display: none !important;
    }
    
    .transfer-badges {
        position: absolute;
        top: 25px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: row; /* 修改为水平排列 */
        flex-wrap: wrap; /* 允许换行 */
        width: 82px; /* 两个宽徽章(约36-38px) + 间距2 = ~78px，给82px余量 */
        justify-content: center; /* 单个徽章时居中对齐 */
        gap: 2px;
        z-index: 3;
    }
    .transfer-badge {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: white;
        font-weight: bold;
    }
    .transfer-badge.wide {
        width: auto;
        min-width: 22px;
        padding: 0 5px;
        border-radius: 11px;
    }

    .layout-one-line .station-labels {
        transform: translateX(-50%);
        left: 50%;
        text-align: center;
        width: max-content;
    }
    .layout-one-line .station-node:nth-child(odd) .station-labels {
        bottom: calc(200% + var(--one-label-offset));
        top: auto;
    }
    .layout-one-line .station-node:nth-child(odd) .transfer-badges {
        top: calc(200% + var(--one-badge-offset));
        bottom: auto;
        left: 50%;
        transform: translateX(-50%);
    }
    .layout-one-line .station-node:nth-child(even) .station-labels {
        top: calc(200% + var(--one-label-offset));
        bottom: auto;
    }
    .layout-one-line .station-node:nth-child(even) .transfer-badges {
        bottom: calc(200% + var(--one-badge-offset));
        top: auto;
        left: 50%;
        transform: translateX(-50%);
    }

    .layout-one-line .station-name {
        text-align: center;
    }
    .layout-one-line .station-name.en {
        text-align: center;
    }

    .layout-one-line .line-row {
        margin-bottom: 30px;
    }

    .layout-one-line .branch-row .station-node:nth-child(odd) .station-labels {
        top: calc(200% + var(--one-label-offset));
        bottom: auto;
    }
    .layout-one-line .branch-row .station-node:nth-child(odd) .transfer-badges {
        bottom: calc(200% + var(--one-badge-offset));
        top: auto;
    }
    .layout-one-line .branch-row .station-node:nth-child(even) .station-labels {
        bottom: calc(200% + var(--one-label-offset));
        top: auto;
    }
    .layout-one-line .branch-row .station-node:nth-child(even) .transfer-badges {
        top: calc(200% + var(--one-badge-offset));
        bottom: auto;
    }

    .layout-two-line .station-labels {
        transform: rotate(var(--two-label-angle));
        left: 50%;
        bottom: calc(150% + var(--two-label-offset));
        top: auto;
        text-align: left;
    }
    .layout-two-line .transfer-badges {
        left: 50%;
        transform: translateX(-50%);
        top: calc(200% + var(--two-badge-offset));
        bottom: auto;
    }
    
    
    /* 滚动条样式 */
    .line-map-container::-webkit-scrollbar { height: 8px; }
    .line-map-container::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 4px; }
    .line-map-container::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
    .line-map-container::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
    
    @keyframes blink { from { opacity: 0.2; } to { opacity: 1; } }
    @keyframes spin { to { transform: rotate(360deg); } }
</style>
{% endblock %}

{% block content %}
<div class="line-map-container">
    <div class="line-map" style="--theme-color: {{ line_color or '#9b5de5' }};">
        
        <!-- 普通线路容器 -->
        <div class="metro-line" id="metro-line">
            <!-- 线路行将通过JavaScript动态生成 -->
        </div>
        <!-- 环线容器 -->
        <div class="ring-line" id="ring-line" style="display:none;">
            <!-- SVG环形轨道与站点将通过JavaScript动态生成 -->
        </div>
        <!-- 将数据以JSON脚本标签形式注入，避免内联JS语法冲突 -->
        <script id="line-info-data" type="application/json">{{ line_info | tojson }}</script>
        <script id="current-route-stations-data" type="application/json">{{ current_route_stations | tojson }}</script>
        <script id="full-route-mode-data" type="application/json">{{ full_route_mode | tojson }}</script>
        <script id="next-station-data" type="application/json">{{ next_station | tojson }}</script>
        <script id="is-reversed-data" type="application/json">{{ is_reversed | tojson }}</script>
        <script id="is-loop-data" type="application/json">{{ is_loop | tojson }}</script>
        <script id="loop-has-terminal-data" type="application/json">{{ loop_has_terminal | tojson }}</script>
        <script id="loop-terminal-station-data" type="application/json">{{ loop_terminal_station | tojson }}</script>
        <script id="direction-data" type="application/json">{{ direction | tojson }}</script>
    <script id="layout-mode-data" type="application/json">{{ layout_mode | tojson }}</script>
    <script id="services-data" type="application/json">{{ services | tojson }}</script>
        <script id="trans-data" type="application/json">{{ trans_data | tojson }}</script>
    </div>
</div>

<div class="navigation-buttons" style="margin-top: 30px; display: flex; justify-content: center; gap: 20px;">
    <button class="btn" onclick="navigateTo('/')">返回首页</button>
    <button class="btn" onclick="navigateTo('/line_detail')">线路详情</button>
</div>
{% endblock %}

{% block scripts %}
<script>
// 线路数据（从JSON脚本标签解析，避免模板语法影响JS解析）
const lineInfo = JSON.parse(document.getElementById('line-info-data')?.textContent || '[]');
const currentRouteStations = JSON.parse(document.getElementById('current-route-stations-data')?.textContent || '[]');
const fullRouteMode = JSON.parse(document.getElementById('full-route-mode-data')?.textContent || 'false');
const currentRouteSet = new Set(currentRouteStations);
const nextStationName = JSON.parse(document.getElementById('next-station-data')?.textContent || 'null');
const isReversed = JSON.parse(document.getElementById('is-reversed-data')?.textContent || 'false');
const isLoop = JSON.parse(document.getElementById('is-loop-data')?.textContent || 'false');
const derection = parseInt(document.getElementById('direction-data')?.textContent || '0');
const transData = JSON.parse(document.getElementById('trans-data')?.textContent || '{}');

// 创建站点节点HTML
function createStationNode(station) {
    const isNext = station.station_name === nextStationName;
    const isTransfer = station.is_transfer;
    const isInactive = (fullRouteMode || window.isCustomBranchMode) && !currentRouteSet.has(station.station_name);
    
    return `
        <div class="station-node">
            <div class="station-circle ${isNext ? 'next' : ''} ${isTransfer ? 'transfer' : ''} ${isInactive ? 'inactive' : ''}"></div>
            ${station.transfer_badges && station.transfer_badges.length > 0 ? `
                <div class="transfer-badges">
                    ${station.transfer_badges.map(b => `
                        <div class="transfer-badge ${String(b.code).length > 1 ? 'wide' : ''}" data-color="${b.color}">${b.code}</div>
                    `).join('')}
                </div>
            ` : ''}
            <div class="station-labels">
                <div class="station-name ${isNext ? 'current' : ''} ${isInactive ? 'inactive' : ''}">${station.station_name}</div>
                <div class="station-name en ${isInactive ? 'inactive' : ''}">${station.station_en_name || station.station_name_en || ''}</div>
            </div>
            ${isNext ? `
                
            ` : ''}
        </div>
    `;
}

// 计算每行能容纳的站点数量
function calculateStationsPerRow() {
    const container = document.querySelector('.line-map-container');
    // 更稳健的宽度测量，避免初次渲染方向切换导致的宽度偏差
    const containerWidth = Math.floor(container.getBoundingClientRect().width || container.clientWidth || container.offsetWidth || 0);
    const stationWidth = 40; // 站点节点宽度
    const layoutModeCalc = JSON.parse(document.getElementById('layout-mode-data')?.textContent || '"auto"');
    const stationSpacingMultiplier = layoutModeCalc === 'auto' ? (parseFloat('{{ station_spacing_multiplier }}') || 1.0) : 1.0;
    const gap = 25 * stationSpacingMultiplier;
    const margin = 40; // 边距
    
    const availableWidth = Math.max(0, containerWidth - margin * 2);
    // 修正计算公式：N个站点需要N-1个间距，公式为 N*w + (N-1)*g <= W => N*(w+g) - g <= W => N <= (W+g)/(w+g)
    const stationsPerRow = Math.floor((availableWidth + gap) / (stationWidth + gap));
    
    return Math.max(1, stationsPerRow);
}

// 创建Z字形布局
function createZigzagLayout() {
    const metroLine = document.getElementById('metro-line');
    const layoutMode = JSON.parse(document.getElementById('layout-mode-data')?.textContent || '"auto"');
    const stationsPerRow = calculateStationsPerRow();

    // 计算满行时的动态间距，用于给不满的行设置相同的间距
    const container = document.querySelector('.line-map-container');
    const containerWidth = Math.floor(container.getBoundingClientRect().width || container.clientWidth || container.offsetWidth || 0);
    const margin = 40;
    const availableWidth = Math.max(0, containerWidth - margin * 2);
    const stationWidth = 40;
    // 如果只有1列，gap无意义；否则计算均匀分布后的实际gap
    const stationSpacingMultiplierAuto = layoutMode === 'auto' ? (parseFloat('{{ station_spacing_multiplier }}') || 1.0) : 1.0;
    let dynamicGap = 25 * stationSpacingMultiplierAuto; 
    if (stationsPerRow > 1) {
        dynamicGap = (availableWidth - stationsPerRow * stationWidth) / (stationsPerRow - 1);
    }

    // 计算全局“下一站”索引并存入容器数据属性
    const globalNextIndex = lineInfo.findIndex(s => s.station_name === nextStationName);
    metroLine.dataset.nextIndex = String(globalNextIndex);
    
    // 清空现有内容
    metroLine.innerHTML = '';
    
    // 自定义布局：one_line 与 two_line
    if (layoutMode === 'one_line') {
        const servicesData = JSON.parse(document.getElementById('services-data')?.textContent || '[]');
        let mainService = null;
        let branchService = null;
        if (servicesData && servicesData.length > 0) {
             branchService = servicesData.find(s => s.branch);
             if (branchService) {
                 mainService = servicesData.find(s => (s.type === branchService.branch || s.service_name === branchService.branch));
                 if (!mainService) {
                     mainService = servicesData.find(s => s !== branchService);
                 }
             }
        }

        if (mainService && branchService) {
            window.isCustomBranchMode = true; // 标记进入自定义分支模式

            const mainStations = mainService.stations;
            const branchStations = branchService.stations;
            let forkIndex = -1;
            const len = Math.min(mainStations.length, branchStations.length);
            for (let i = 0; i < len; i++) {
                if (mainStations[i] !== branchStations[i]) {
                    break;
                }
                forkIndex = i;
            }
            
            if (forkIndex >= 0 && forkIndex < mainStations.length - 1 && forkIndex < branchStations.length - 1) {
                function getStationObj(name) {
                    let s = lineInfo.find(s => s.station_name === name);
                    if (s) return s;
                    const isInactive = !currentRouteSet.has(name);
                    return {
                        station_name: name,
                        station_name_en: s ? (s.station_en_name || s.station_name_en) : (transData[name] || name),
                        is_transfer: false,
                        transfer_lines: [],
                        transfer_badges: []
                    };
                }
                const isDirReverse = derection === 1;
                const forkIndexOrig = forkIndex;
                const mainStationObjs = (isDirReverse ? mainStations.slice().reverse().map(getStationObj) : mainStations.map(getStationObj));
                const branchStationObjs = branchStations.slice(forkIndexOrig + 1).map(getStationObj);
                
                const rowMain = document.createElement('div');
                rowMain.className = 'line-row';
                rowMain.style.position = 'relative';
                rowMain.dataset.branchMode = 'main';
                const N = mainStationObjs.length;
                if (isDirReverse) {
                    forkIndex = N - 1 - forkIndexOrig;
                }
                rowMain.dataset.forkIndex = String(forkIndex);
                rowMain.dataset.startIndex = '0';
                rowMain.dataset.endIndex = String(mainStationObjs.length - 1);
                rowMain.innerHTML = mainStationObjs.map(createStationNode).join('');
                
                const containerWidth2 = Math.floor(container.getBoundingClientRect().width || container.clientWidth || container.offsetWidth || 0);
                const availableWidth2 = Math.max(0, containerWidth2 - margin * 2);
                let gap1 = N > 1 ? (availableWidth2 - N * stationWidth) / (N - 1) : 0;
                gap1 = Math.max(8, gap1);
                
                const baseGap = 25;
                const ratio = Math.max(0.6, Math.min(1.0, gap1 / baseGap));
                metroLine.style.setProperty('--rail-thickness', Math.round(15 * ratio) + 'px');
                metroLine.style.setProperty('--arrow-size', Math.round(25 * ratio) + 'px');
                
                rowMain.style.justifyContent = 'flex-start';
                rowMain.style.gap = gap1 + 'px';
                metroLine.appendChild(rowMain);
                
                const rowBranch = document.createElement('div');
                rowBranch.className = 'line-row branch-row' + (isDirReverse ? ' reverse' : '');
                rowBranch.style.position = 'relative';
                rowBranch.style.marginTop = '60px';
                rowBranch.style.justifyContent = 'flex-start';
                rowBranch.style.gap = gap1 + 'px';
                
                const offset = (stationWidth + gap1) * (forkIndexOrig + 2);
                const branchRailWidth = (branchStationObjs.length * stationWidth + Math.max(0, branchStationObjs.length - 1) * gap1);
                
                if (isDirReverse) {
                    // Reverse Mode: Align Right (flex-start in row-reverse), Push Left by offset
                    rowBranch.style.paddingRight = offset + 'px';
                    rowBranch.style.paddingLeft = '0';
                    rowBranch.style.setProperty('--rail-left', 'auto');
                    rowBranch.style.setProperty('--rail-right', offset*1.01 + 'px');
                } else {
                    // Normal Mode: Align Left, Push Right by offset
                    rowBranch.style.paddingLeft = offset + 'px';
                    rowBranch.style.paddingRight = '0';
                    rowBranch.style.setProperty('--rail-left', offset*1.01 + 'px');
                    rowBranch.style.setProperty('--rail-right', 'auto');
                }
                
                rowBranch.style.setProperty('--rail-width', branchRailWidth*0.7 + 'px');
                
                rowBranch.dataset.startIndex = String(forkIndexOrig + 1);
                rowBranch.dataset.endIndex = String(forkIndexOrig + 1 + branchStationObjs.length - 1);
                
                // 检查分支是否激活
                const isBranchActive = branchStationObjs.some(s => currentRouteSet.has(s.station_name));
                if (!isBranchActive) {
                    rowBranch.classList.add('inactive-row');
                } else {
                    // 如果分支激活，计算分支行的着色范围（Next Station -> End）
                    // Find next station in branch row
                    const branchNextIndex = branchStationObjs.findIndex(s => s.station_name === nextStationName);
                    
                    if (branchNextIndex >= 0) {
                         // Next station is on Branch Row.
                         // Color from Next -> End.
                         const startIdx = branchNextIndex;
                         const endIdx = branchStationObjs.length - 1;
                         
                         // Mark passed stations in branch row (0..Next-1)
                         // Wait, we need to apply this AFTER adding to DOM? No, stations are not in DOM yet?
                         // Ah, logic below handles creation.
                         // We need to inject "passed" class into createStationNode or post-process.
                         // Let's use post-process.
                         
                         // We'll add a data attribute to rowBranch to help computeRailAndConnectors logic?
                         // Or we can just let standard logic handle it?
                         // Standard logic: "if (globalNextIndex >= rowStart ...)"
                         // But rowStart is just index offset.
                         // Our branch row stations are not contiguous in lineInfo?
                         // Actually they are mocked objects or real objects.
                         // Standard logic relies on "row.dataset.startIndex".
                         // In Branch Mode, we set startIndex/endIndex manually.
                         // But `globalNextIndex` is based on `lineInfo` index.
                         // If Branch Stations are NOT in `lineInfo` (or index mismatch), standard logic fails.
                         // So we should implement Custom Coloring for Branch Row too, inside computeRailAndConnectors.
                         rowBranch.dataset.branchMode = 'branch';
                    } else {
                         // Next station NOT in Branch Row.
                         // If Next is in Main Row (before Fork), then Branch Row is FUTURE.
                         // So Color Start -> End.
                         // Check if Next is in Main Row (before Fork).
                         // We can assume if Branch is Active, and Next is not in Branch, it's upstream.
                         rowBranch.dataset.branchMode = 'branch';
                    }
                }
                
                rowBranch.innerHTML = branchStationObjs.map(createStationNode).join('');
                metroLine.appendChild(rowBranch);
                
                // Post-process "passed" status for branch stations if needed (initial render)
                // Actually computeRailAndConnectors is called on init/resize.
                // So we should put logic there.
                
                requestAnimationFrame(() => {
                    const forkStation = rowMain.children[forkIndex];
                    const branchStartStation = rowBranch.children[0];
                    if (forkStation && branchStartStation) {
                        const rect1 = forkStation.getBoundingClientRect();
                        const rect2 = branchStartStation.getBoundingClientRect();
                        const containerRect = metroLine.getBoundingClientRect();
                        
                        const x1 = rect1.left + rect1.width / 2 - containerRect.left;
                        const y1 = rect1.top + rect1.height / 2 - containerRect.top;
                        const x2 = rect2.left + rect2.width / 2 - containerRect.left;
                        const y2 = rect2.top + rect2.height / 2 - containerRect.top;
                        
                        const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                        const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                        
                        const connector = document.createElement('div');
                        connector.className = 'branch-connector';
                        connector.style.position = 'absolute';
                        connector.style.top = y1 + 'px';
                        connector.style.left = x1 + 'px';
                        connector.style.width = length + 'px';
                        connector.style.height = '15px';
                        connector.style.transformOrigin = '0 50%';
                        connector.style.transform = `rotate(${angle}deg) translateY(-50%)`;
                        connector.style.borderRadius = '8px';
                        connector.style.zIndex = '0';
                        
                        const themeColor = getComputedStyle(metroLine).getPropertyValue('--theme-color').trim() || '#9b5de5';
                        const isPassed = branchStartStation.querySelector('.station-circle').classList.contains('passed');
                        const branchStationsNow = Array.from(rowBranch.querySelectorAll('.station-node'));
                        const nextInBranchIdx = branchStationsNow.findIndex(s => s.querySelector('.station-name').textContent === nextStationName);
                        let toColor = false;
                        if (nextInBranchIdx >= 0) {
                            const direction = parseInt(document.getElementById('direction-data')?.textContent || '0');
                            toColor = (direction === 1);
                        } else if (isBranchActive && !isPassed) {
                            toColor = true;
                        }
                        connector.style.backgroundColor = toColor ? themeColor : '#ddd';
                        
                        metroLine.appendChild(connector);
                    }
                });
                
                return;
            }
        }

        const row = document.createElement('div');
        row.className = 'line-row';
        row.dataset.startIndex = '0';
        row.dataset.endIndex = String(lineInfo.length - 1);
        const oneLineStations = derection === 1 ? lineInfo.slice().reverse() : lineInfo;
        row.innerHTML = oneLineStations.map(createStationNode).join('');
        const containerWidth2 = Math.floor(container.getBoundingClientRect().width || container.clientWidth || container.offsetWidth || 0);
        const availableWidth2 = Math.max(0, containerWidth2 - margin * 2);
        const N = lineInfo.length;
        let gap1 = N > 1 ? (availableWidth2 - N * stationWidth) / (N - 1) : 0;
        gap1 = Math.max(8, gap1);
        const baseGap = 25;
        const ratio = Math.max(0.6, Math.min(1.0, gap1 / baseGap));
        metroLine.style.setProperty('--rail-thickness', Math.round(15 * ratio) + 'px');
        metroLine.style.setProperty('--arrow-size', Math.round(25 * ratio) + 'px');
        row.style.justifyContent = 'flex-start';
        row.style.gap = gap1 + 'px';
        metroLine.appendChild(row);
        return;
    }
    if (layoutMode === 'two_line') {
        const topCount = Math.ceil(lineInfo.length / 2);
        const bottomCount = Math.floor(lineInfo.length / 2);
        const rowTop = document.createElement('div');
        rowTop.className = 'line-row';
        rowTop.dataset.startIndex = '0';
        rowTop.dataset.endIndex = String(topCount - 1);
        rowTop.innerHTML = lineInfo.slice(0, topCount).map(createStationNode).join('');
        const containerWidth2 = Math.floor(container.getBoundingClientRect().width || container.clientWidth || container.offsetWidth || 0);
        const availableWidth2 = Math.max(0, containerWidth2 - margin * 2);
        const N1 = topCount;
        let gapTop = N1 > 1 ? (availableWidth2 - N1 * stationWidth) / (N1 - 1) : 0;
        gapTop = Math.max(8, gapTop);
        rowTop.style.justifyContent = 'flex-start';
        rowTop.style.gap = gapTop + 'px';
        metroLine.appendChild(rowTop);
        if (bottomCount > 0) {
            const rowBottom = document.createElement('div');
            rowBottom.className = 'line-row reverse';
            rowBottom.dataset.startIndex = String(topCount);
            rowBottom.dataset.endIndex = String(lineInfo.length - 1);
            rowBottom.innerHTML = lineInfo.slice(topCount).map(createStationNode).join('');
            const N2 = bottomCount;
            let gapBottom = N2 > 1 ? (availableWidth2 - N2 * stationWidth) / (N2 - 1) : 0;
            gapBottom = Math.max(8, gapBottom);
            rowBottom.style.justifyContent = 'flex-end';
            rowBottom.style.gap = gapBottom + 'px';
            const baseGap2 = 25;
          const ratio2 = Math.max(0.6, Math.min(1.0, Math.min(gapTop, gapBottom) / baseGap2));
          metroLine.style.setProperty('--rail-thickness', '15px'); // 保持固定宽度
          metroLine.style.setProperty('--arrow-size', Math.round(25 * ratio2) + 'px');
            metroLine.appendChild(rowBottom);
        }
        return;
    }
    
    // 创建多行Z字形布局
    let currentIndex = 0;
    let rowIndex = 0;
    
    console.log(`总站点数: ${lineInfo.length}, 每行站点数: ${stationsPerRow}`);
    
    while (currentIndex < lineInfo.length) {
        const row = document.createElement('div');
        // 修正：行索引为奇数的行翻转（第2、4、6...行）
        const isReverse = rowIndex % 2 === 1; // 行索引从0开始，奇数索引对应偶数行
        row.className = `line-row ${isReverse ? 'reverse' : ''}`;
        
        // 计算当前行的站点范围
        const startIndex = currentIndex;
        const endIndex = Math.min(currentIndex + stationsPerRow, lineInfo.length);
        const rowStations = lineInfo.slice(startIndex, endIndex);

        // 如果该行不满（通常是最后一行），改用 flex-start 并设置 calculated gap
        if (rowStations.length < stationsPerRow) {
            row.style.justifyContent = 'flex-start';
            row.style.gap = `${dynamicGap}px`;
        }
        
        // 记录该行的索引范围（闭区间）
        row.dataset.startIndex = String(startIndex);
        row.dataset.endIndex = String(endIndex - 1);
        
        console.log(`第${rowIndex + 1}行 (索引${rowIndex}): ${isReverse ? '反向' : '正向'}, 站点: ${startIndex + 1}-${endIndex}`);
        if (isReverse) {
            console.log(`  反向行（CSS反排）: ${rowStations.map(s => s.station_name).join(' → ')}`);
        }
        
        row.innerHTML = rowStations.map(createStationNode).join('');
        metroLine.appendChild(row);
        
        // 连接线改由计算阶段基于实际位置添加，这里不再创建
        
        currentIndex = endIndex;
        rowIndex++;
    }
}

function applyCustomLayoutStyles() {
    const layoutMode = JSON.parse(document.getElementById('layout-mode-data')?.textContent || '"auto"');
    const isLoop = JSON.parse(document.getElementById('is-loop-data')?.textContent || 'false');
    if (isLoop) return;
    const metroLine = document.getElementById('metro-line');
    metroLine.classList.remove('layout-one-line', 'layout-two-line');
    if (layoutMode === 'one_line') {
        metroLine.classList.add('layout-one-line');
    } else if (layoutMode === 'two_line') {
        metroLine.classList.add('layout-two-line');
    }
}

// 计算轨道和连接线
function computeRailAndConnectors() {
    const metroLine = document.getElementById('metro-line');
    const metroRect = metroLine.getBoundingClientRect();
    const thickness = parseFloat(getComputedStyle(metroLine).getPropertyValue('--rail-thickness')) || 15;
    const metroWidth = Math.floor(metroRect.width || metroLine.clientWidth || metroLine.offsetWidth || 0);

    const rows = Array.from(document.querySelectorAll('.line-row'));

    // 清理旧连接线和旧箭头
    metroLine.querySelectorAll('.connector').forEach(el => el.remove());
    metroLine.querySelectorAll('.direction-arrow').forEach(el => el.remove());
    
    // 先计算每行的轨道（灰色与彩色段）
    rows.forEach((row, rowIndex) => {
        if (row.classList.contains('inactive-row')) return;

        const stations = Array.from(row.querySelectorAll('.station-node'));
        
        const rowLeft = row.getBoundingClientRect().left;

        // Custom logic for branch mode 'main' row
        if (row.dataset.branchMode === 'main') {
            const firstRect = stations[0].getBoundingClientRect();
            const lastRect = stations[stations.length - 1].getBoundingClientRect();
            const firstCenterX = firstRect.left + firstRect.width / 2;
            const lastCenterX = lastRect.left + lastRect.width / 2;
            const railLeft = Math.min(firstCenterX, lastCenterX) - rowLeft;
            const railWidth = Math.abs(lastCenterX - firstCenterX);
            row.style.setProperty('--rail-left', Math.max(0, railLeft) + 'px');
            row.style.setProperty('--rail-width', railWidth + 'px');

            let coloredLeft = Math.max(0, railLeft);
            let coloredWidth = 0;
            const forkIndex = parseInt(row.dataset.forkIndex || '-1');
            
            // Find next station in this row
            let nextStationInRowIndex = -1;
            const nextStationName = JSON.parse(document.getElementById('next-station-data')?.textContent || 'null');
            stations.forEach((s, i) => {
                if (s.querySelector('.station-name').textContent === nextStationName) {
                    nextStationInRowIndex = i;
                }
            });

            // Logic Correction: "Passed segments should be Gray, Future segments should be Colored."
            // We color from StartIndex (Next Station) to EndIndex (End of Active Route).
            
            let startColorIndex = -1;
            let endColorIndex = -1;
            
            // Determine active range for this row
            if (nextStationInRowIndex >= 0) {
                // Next station is in this row (Main Row or Branch Row)
                startColorIndex = nextStationInRowIndex;
                endColorIndex = stations.length - 1; 

                // Check if branch is active and we are in Main Row
                // If branch is active, Main Row extension (Fork..End) should be inactive IF Next is before Fork.
                const branchRow = document.querySelector('.branch-row');
                const isBranchActive = branchRow && !branchRow.classList.contains('inactive-row');
                
                if (isBranchActive && forkIndex >= 0) {
                    // We are in Main Row, Branch is Active.
                    // If Next Station is BEFORE or AT Fork, the Main Extension (Fork..End) is NOT the active path.
                    // The active path goes to Branch.
                    if (nextStationInRowIndex <= forkIndex) {
                        endColorIndex = forkIndex;
                    }
                }
            } else {
                // Next station NOT in this row.
                if (row.classList.contains('branch-row')) {
                    // We are in Branch Row. Next is likely in Main Row.
                    // Check if Next is effectively "after" the branch (meaning Branch is Passed).
                    // Or "before" the branch (meaning Branch is Future).
                    const mainRow = document.querySelector('.line-row:not(.branch-row)');
                    if (mainRow) {
                        const forkIdx = parseInt(mainRow.dataset.forkIndex || '-1');
                        const mainStations = Array.from(mainRow.querySelectorAll('.station-node'));
                        const nextInMainIdx = mainStations.findIndex(s => s.querySelector('.station-name').textContent === nextStationName);
                        
                        if (nextInMainIdx >= 0) {
                            if (nextInMainIdx > forkIdx) {
                                // Next is after Fork on Main Line.
                                // Branch is Passed (or Skipped).
                                // Mark all branch stations as passed.
                                stations.forEach(s => s.querySelector('.station-circle').classList.add('passed'));
                                startColorIndex = -1; // No color
                            } else {
                                // Next is before Fork. Branch is Future.
                                startColorIndex = 0;
                                endColorIndex = stations.length - 1;
                            }
                        }
                    }
                } else {
                    // We are in Main Row. Next is likely in Branch Row.
                    const branchRow = document.querySelector('.branch-row');
                    if (branchRow) {
                         const branchStations = Array.from(branchRow.querySelectorAll('.station-node'));
                         const nextInBranch = branchStations.some(s => s.querySelector('.station-name').textContent === nextStationName);
                         if (nextInBranch) {
                             // Next is on Branch.
                             const direction = parseInt(document.getElementById('direction-data')?.textContent || '0');
                             
                             if (direction === 1) {
                                 // Reverse: Branch -> Fork -> Main(0..Fork).
                                 // Main(0..Fork) is Future (Active).
                                 startColorIndex = forkIndex;
                                 endColorIndex = 0;
                                 // Do NOT mark as passed.
                             } else {
                                 // Forward: Main(0..Fork) -> Branch.
                                 // Main(0..Fork) is Passed.
                                 // Main Row Fork..End are Inactive (Gray).
                                 startColorIndex = -1; // No colored rail for the main row after fork
                                 endColorIndex = -1;
                                 
                                 // Mark 0..Fork as passed
                                 stations.forEach((s, i) => {
                                     if (i <= forkIndex) {
                                         s.querySelector('.station-circle').classList.add('passed');
                                     }
                                 });
                             }
                         }
                    }
                }
            }
            
            // Mark passed stations (grey out) for current row if next is present
            if (nextStationInRowIndex >= 0) {
                 stations.forEach((s, i) => {
                     if (i < nextStationInRowIndex) {
                         s.querySelector('.station-circle').classList.add('passed');
                     }
                 });
            } else {
                // If next is not in row, we already handled passed marking above for specific cases.
            }
            
            if (startColorIndex !== -1 && endColorIndex !== -1) {
                const currentStart = Math.min(startColorIndex, endColorIndex);
                const currentEnd = Math.max(startColorIndex, endColorIndex);
                const startRect = stations[currentStart].getBoundingClientRect();
                const endRect = stations[currentEnd].getBoundingClientRect();
                const startCenterX = startRect.left + startRect.width / 2;
                const endCenterX = endRect.left + endRect.width / 2;
                coloredLeft = Math.min(startCenterX, endCenterX) - rowLeft;
                coloredWidth = Math.abs(endCenterX - startCenterX);
            }
            
            row.style.setProperty('--rail-colored-left', Math.max(0, coloredLeft) + 'px');
            row.style.setProperty('--rail-colored-width', coloredWidth + 'px');
            
            const rowCenterY = row.getBoundingClientRect().height / 2;
             for (let seg = 0; seg < stations.length - 1; seg++) {
                 let colorClass = 'black'; // Future = Black/Theme
                 
                 // Passed = Gray
                 if (nextStationInRowIndex >= 0) {
                     if (seg < nextStationInRowIndex - 1) colorClass = 'gray'; // Before next station -> Passed
                     else if (seg === nextStationInRowIndex - 1) colorClass = 'red'; // Approaching next
                 } else {
                     // Next not in row.
                     // If on branch, 0..Fork are passed.
                     if (seg < forkIndex) {
                         const direction = parseInt(document.getElementById('direction-data')?.textContent || '0');
                         if (direction === 1) {
                                     colorClass = (seg < forkIndex) ? 'black' : 'gray';
                                 } else {
                                     colorClass = 'gray';
                                 }
                     }
                     else {
                         // Segments after fork on Main Row (when Next is on Branch)
                         // These are Inactive Main Route segments.
                         // Should probably be Gray or hidden arrows?
                         // Let's make them black (default) but they sit on gray rail.
                     }
                 }
                 
                 // If segment is inactive (e.g. past fork on Main Row when Branch is active)
                 // Or past fork on Branch Row when Main is active (handled by inactive-row)
                 
                 // Skip inactive segments arrows
                 // if (seg >= forkIndex && nextStationInRowIndex < 0) continue; 
                 
                 const aRect = stations[seg].getBoundingClientRect();
                 const bRect = stations[seg + 1].getBoundingClientRect();
                 const aX = aRect.left + aRect.width / 2;
                 const bX = bRect.left + bRect.width / 2;
                 let midX = (aX + bX) / 2 - rowLeft;
                 midX = Math.max(0, Math.min(row.getBoundingClientRect().width, midX));
                 
                 const arrow = document.createElement('div');
                 arrow.className = 'direction-arrow ' + colorClass;
                 arrow.textContent = '→';
                 arrow.style.left = midX + 'px';
                 arrow.style.top = rowCenterY + 'px';
                 arrow.style.transform = 'translate(-50%, -50%)';
                 row.appendChild(arrow);
             }
             return;
        }

        // Custom logic for branch mode 'branch' row
        if (row.dataset.branchMode === 'branch') {
             const firstRect = stations[0].getBoundingClientRect();
             const lastRect = stations[stations.length - 1].getBoundingClientRect();
             const firstCenterX = firstRect.left + firstRect.width / 2;
             const lastCenterX = lastRect.left + lastRect.width / 2;
             const railWidth = Math.abs(lastCenterX - firstCenterX);
             
             if (row.classList.contains('reverse')) {
                 const rowRight = row.getBoundingClientRect().right;
                 const railRight = rowRight - Math.max(firstCenterX, lastCenterX);
                 row.style.setProperty('--rail-left', 'auto');
                 row.style.setProperty('--rail-right', Math.max(0, railRight) + 'px');
             } else {
                 const railLeft = Math.min(firstCenterX, lastCenterX) - rowLeft;
                 row.style.setProperty('--rail-left', Math.max(0, railLeft) + 'px');
                 row.style.setProperty('--rail-right', 'auto');
             }
             row.style.setProperty('--rail-width', railWidth + 'px');
             
             // Find next station in this branch row
             let nextStationInRowIndex = -1;
             const nextStationName = JSON.parse(document.getElementById('next-station-data')?.textContent || 'null');
             stations.forEach((s, i) => {
                 if (s.querySelector('.station-name').textContent === nextStationName) {
                     nextStationInRowIndex = i;
                 }
             });
             
             let coloredLeft = 0;
             let coloredRight = 0;
             let coloredWidth = 0;
             let startColorIndex = -1;
             
             // Initial defaults based on rail position
             if (row.classList.contains('reverse')) {
                 const rowRight = row.getBoundingClientRect().right;
                 coloredRight = rowRight - Math.max(firstCenterX, lastCenterX);
             } else {
                 coloredLeft = Math.min(firstCenterX, lastCenterX) - rowLeft;
             }
             
             if (nextStationInRowIndex >= 0) {
                 // Next is in this row. Color from Next -> End.
                 startColorIndex = nextStationInRowIndex;
                 // Mark passed
                 const direction = parseInt(document.getElementById('direction-data')?.textContent || '0'); // 获取方向
                 stations.forEach((s, i) => {
                     if (direction === 1) { // 反向模式
                         if (i > nextStationInRowIndex) { // 标记下一站之后的站点为passed
                             s.querySelector('.station-circle').classList.add('passed');
                         }
                     } else { // 正向模式
                         if (i < nextStationInRowIndex) { // 标记下一站之前的站点为passed
                             s.querySelector('.station-circle').classList.add('passed');
                         }
                     }
                 });
             } else {
                 // Next is NOT in this row.
                 // Check if Next is on Main Line AFTER the fork.
                 const mainRow = document.querySelector('.line-row:not(.branch-row)');
                 if (mainRow) {
                     const forkIdx = parseInt(mainRow.dataset.forkIndex || '-1');
                     const mainStations = Array.from(mainRow.querySelectorAll('.station-node'));
                     const nextInMainIdx = mainStations.findIndex(s => s.querySelector('.station-name').textContent === nextStationName);
                     
                     if (nextInMainIdx >= 0) {
                        // Check Direction!
                        // If Forward (0): Main(0..F) -> Branch.
                        // If Reverse (1): Branch -> Main(F..0).
                        
                        // Wait, "Main Line AFTER the fork" depends on direction?
                        // "After the fork" usually means the extension part (F+1..N).
                        // If Reverse: Branch -> Fork -> Main(0..F).
                        // The "Extension" (F+1..N) is not part of the route.
                        
                        // If nextInMainIdx > forkIdx:
                        // This implies Next is on the extension part.
                        // If Route is Main->Main, Branch is inactive.
                        // If Route is Main->Branch, Next shouldn't be there.
                        
                        // Let's rely on "passed" logic.
                        // If Next is in Main (anywhere), Branch is either Passed or Future.
                        // Forward: Main(Next) -> Fork -> Branch. (Next < Fork). Branch is Future.
                        // Forward: Fork -> Branch(Next). (Next in Branch). Branch is Active.
                        // Forward: Main(Next) -> End. (Next > Fork). Branch is Inactive/Passed.
                        
                        // Reverse: Branch(Next) -> Fork -> Main. (Next in Branch). Branch is Active.
                        // Reverse: Branch -> Fork -> Main(Next). (Next < Fork). Branch is Passed.
                        
                        if (nextInMainIdx > forkIdx) {
                            // Forward: Next is after fork. Branch is Passed/Inactive.
                            stations.forEach(s => s.querySelector('.station-circle').classList.add('passed'));
                            startColorIndex = -1; 
                        } else {
                            // Next is before Fork.
                            // Forward: Branch is Future.
                            // Reverse: Branch is Passed.
                            
                            const direction = parseInt(document.getElementById('direction-data')?.textContent || '0');
                            if (direction === 1) {
                                // Reverse: Branch -> Fork -> Main(Next).
                                // Branch is Passed.
                                stations.forEach(s => s.querySelector('.station-circle').classList.add('passed'));
                                startColorIndex = -1;
                            } else {
                                // Forward: Main(Next) -> Fork -> Branch.
                                // Branch is Future.
                                startColorIndex = 0;
                            }
                        }
                     } else {
                         // Next not in Main? (Maybe data error or not found).
                         // Assume Future.
                         startColorIndex = 0;
                     }
                 } else {
                     // No main row found, assume branch is future.
                     startColorIndex = 0;
                 }
             }
             
             if (startColorIndex >= 0) {
                 const direction = parseInt(document.getElementById('direction-data')?.textContent || '0');
                 const endColorIndex = (direction === 1) ? 0 : (stations.length - 1);
                 const startRect = stations[startColorIndex].getBoundingClientRect();
                 const endRect = stations[endColorIndex].getBoundingClientRect();
                 const startCenterX = startRect.left + startRect.width / 2;
                 const endCenterX = endRect.left + endRect.width / 2;
                 
                 coloredWidth = Math.abs(endCenterX - startCenterX);
                 
                 if (row.classList.contains('reverse')) {
                     const rowRight = row.getBoundingClientRect().right;
                     coloredRight = rowRight - Math.max(startCenterX, endCenterX);
                     // Check if width is correct.
                     // startColorIndex (Next) -> EndIndex (End of Row).
                     // In Reverse, End of Row is Leftmost (index N).
                     // Start (Next) is somewhere.
                     // Colored part: Next -> End (Leftward).
                     // coloredRight = Distance from Row Right Edge to Rightmost point of colored segment.
                     // Colored segment is between startCenterX and endCenterX.
                     // Rightmost point is max(startCenterX, endCenterX).
                     // This looks correct.
                 } else {
                     coloredLeft = Math.min(startCenterX, endCenterX) - rowLeft;
                 }
             }
             
             if (row.classList.contains('reverse')) {
                 row.style.setProperty('--rail-colored-left', 'auto');
                 row.style.setProperty('--rail-colored-right', Math.max(0, coloredRight) + 'px');
             } else {
                 row.style.setProperty('--rail-colored-left', Math.max(0, coloredLeft) + 'px');
                 row.style.setProperty('--rail-colored-right', 'auto');
             }
             row.style.setProperty('--rail-colored-width', coloredWidth + 'px');
             
             const rowCenterY = row.getBoundingClientRect().height / 2;
             for (let seg = 0; seg < stations.length - 1; seg++) {
                 let colorClass = 'black';
                 if (nextStationInRowIndex >= 0) {
                     if (seg < nextStationInRowIndex - 1) colorClass = 'gray';
                     else if (seg === nextStationInRowIndex - 1) colorClass = 'red';
                 } else {
                     // Entire row is future
                     colorClass = 'black';
                 }
                 
                 const aRect = stations[seg].getBoundingClientRect();
                 const bRect = stations[seg + 1].getBoundingClientRect();
                 const aX = aRect.left + aRect.width / 2;
                 const bX = bRect.left + bRect.width / 2;
                 let midX = (aX + bX) / 2 - rowLeft;
                 midX = Math.max(0, Math.min(row.getBoundingClientRect().width, midX));
                 
                 const arrow = document.createElement('div');
                 arrow.className = 'direction-arrow ' + colorClass;
                 arrow.textContent = '→';
                 arrow.style.left = midX + 'px';
                 arrow.style.top = rowCenterY + 'px';
                 arrow.style.transform = 'translate(-50%, -50%)';
                 row.appendChild(arrow);
             }
             return;
        }
        
        if (stations.length < 2) {
            // 单站点行：不显示轨道
            row.style.setProperty('--rail-left', '0px');
            row.style.setProperty('--rail-width', '0px');
            row.style.setProperty('--rail-colored-left', '0px');
            row.style.setProperty('--rail-colored-width', '0px');
            return;
        }
        
        const firstRect = stations[0].getBoundingClientRect();
        const lastRect = stations[stations.length - 1].getBoundingClientRect();
        
        const firstCenterX = firstRect.left + firstRect.width / 2;
        const lastCenterX = lastRect.left + lastRect.width / 2;
        
        // 轨道起止点对齐站点圆心，避免在端侧突出
        const railLeft = Math.min(firstCenterX, lastCenterX) - rowLeft;
        const railWidth = Math.abs(lastCenterX - firstCenterX);
        
        // 左侧越界保护，避免负 left 导致轨道起点在容器外
        row.style.setProperty('--rail-left', Math.max(0, railLeft) + 'px');
        row.style.setProperty('--rail-width', railWidth + 'px');

        // 根据全局“下一站”索引判断整行着色逻辑
        const globalNextIndex = parseInt(document.getElementById('metro-line').dataset.nextIndex || '-1');
        const rowStart = parseInt(row.dataset.startIndex || '-1');
        const rowEnd = parseInt(row.dataset.endIndex || '-1');

        let coloredLeft = Math.max(0, railLeft);
        let coloredWidth = 0;

        // 计算当前子路线的全局活动区间（activeStart..activeEnd）
        const activeIndices = currentRouteStations.length ? lineInfo.map((s, i) => currentRouteSet.has(s.station_name) ? i : -1).filter(i => i >= 0) : [];
        const activeStart = activeIndices.length ? Math.min(...activeIndices) : -1;
        const activeEnd = activeIndices.length ? Math.max(...activeIndices) : -1;
        const hasActiveRange = fullRouteMode && activeStart >= 0 && activeEnd >= 0;
        
        if (!isNaN(globalNextIndex) && !isNaN(rowStart) && !isNaN(rowEnd)) {
            if (globalNextIndex >= rowStart && globalNextIndex <= rowEnd) {
                // 下一站在本行：从下一站到活动区间端点（或行端）着色
                const localNextIndex = stations.findIndex(station => 
                    station.querySelector('.station-circle').classList.contains('next')
                );
                // 已走过标记：方向不依赖视觉反排，统一按“下一站之前”为已走过
                const isReverseRow = row.classList.contains('reverse');
                stations.forEach((station, idx) => {
                    const globalIdx = rowStart + idx;
                    const circle = station.querySelector('.station-circle');
                    const isActive = !hasActiveRange ? true : (globalIdx >= activeStart && globalIdx <= activeEnd);
                    if (isActive && localNextIndex >= 0) {
                        const isPassed = idx < localNextIndex; // 修正：反转行也按索引小于下一站为已走过
                        if (isPassed) {
                            circle.classList.add('passed');
                        }
                    }
                });
                if (localNextIndex >= 0) {
                    const nextRect = stations[localNextIndex].getBoundingClientRect();
                    const nextCenterX = nextRect.left + nextRect.width / 2;
                    let endIndexForColor;
                    if (hasActiveRange) {
                        const rowActiveStart = Math.max(rowStart, activeStart);
                        const rowActiveEnd = Math.min(rowEnd, activeEnd);
                        if (rowActiveStart <= rowActiveEnd) {
                            // 修正：未走过段应从下一站延伸到行的“末端”（活动区间内的较大索引），与视觉反排无关
                            endIndexForColor = (rowActiveEnd - rowStart);
                        }
                    }
                    if (endIndexForColor === undefined) {
                        // 未走过段（无活动区间）统一延伸到行末端（较大索引）
                        endIndexForColor = stations.length - 1;
                    }
                    const endRect = stations[endIndexForColor].getBoundingClientRect();
                    const endCenterX = endRect.left + endRect.width / 2;
                    coloredLeft = Math.min(nextCenterX, endCenterX) - rowLeft;
                    coloredWidth = Math.abs(endCenterX - nextCenterX);
                }
            } else if (globalNextIndex < rowStart) {
                // 下一站在本行之前：本行尚未到达，若存在活动区间，仅着色活动区间部分
                if (hasActiveRange) {
                    const rowActiveStart = Math.max(rowStart, activeStart);
                    const rowActiveEnd = Math.min(rowEnd, activeEnd);
                    if (rowActiveStart <= rowActiveEnd) {
                        const startRect = stations[rowActiveStart - rowStart].getBoundingClientRect();
                        const endRect = stations[rowActiveEnd - rowStart].getBoundingClientRect();
                        const startX = startRect.left + startRect.width / 2;
                        const endX = endRect.left + endRect.width / 2;
                        coloredLeft = Math.min(startX, endX) - rowLeft;
                        coloredWidth = Math.abs(endX - startX);
                    } else {
                        coloredLeft = Math.max(0, railLeft);
                        coloredWidth = 0;
                    }
                } else {
                    coloredLeft = Math.max(0, railLeft);
                    coloredWidth = railWidth;
                }
            } else {
                // 下一站在本行之后：本行已全部经过，仅将活动区间站标记为已过
                coloredLeft = Math.max(0, railLeft);
                coloredWidth = 0;
                stations.forEach((station, idx) => {
                    const globalIdx = rowStart + idx;
                    const circle = station.querySelector('.station-circle');
                    const isActive = !hasActiveRange ? true : (globalIdx >= activeStart && globalIdx <= activeEnd);
                    if (isActive) circle.classList.add('passed');
                });
            }
        }
        
        // 左侧越界保护，避免彩色段起点在容器外
        row.style.setProperty('--rail-colored-left', Math.max(0, coloredLeft) + 'px');
        row.style.setProperty('--rail-colored-width', coloredWidth + 'px');

        // 为本行每个水平线段添加方向箭头（不处理换行处横线）
        const isReverseRow = row.classList.contains('reverse');
        const rowCenterY = row.getBoundingClientRect().height / 2;
        for (let seg = 0; seg < stations.length - 1; seg++) {
            const aRect = stations[seg].getBoundingClientRect();
            const bRect = stations[seg + 1].getBoundingClientRect();
            const aX = aRect.left + aRect.width / 2;
            const bX = bRect.left + bRect.width / 2;
            let midX = (aX + bX) / 2 - row.getBoundingClientRect().left;
            // 左侧越界保护，保证箭头不会在行容器外
            midX = Math.max(0, Math.min(row.getBoundingClientRect().width, midX));
            const arrow = document.createElement('div');
            
            const rowStartIndex = parseInt(row.dataset.startIndex || '-1');
            const globalNextIndex = parseInt(document.getElementById('metro-line').dataset.nextIndex || '-1');
            const laterIndex = (isNaN(rowStartIndex) ? (seg + 1) : (rowStartIndex + seg + 1));

            // 仅在活动区间内绘制箭头；活动外的线段保持静止且不显示箭头
            let activeStartIdx = -1, activeEndIdx = -1;
            if (fullRouteMode) {
                const activeIndices = currentRouteStations.length ? lineInfo.map((s, i) => currentRouteSet.has(s.station_name) ? i : -1).filter(i => i >= 0) : [];
                activeStartIdx = activeIndices.length ? Math.min(...activeIndices) : -1;
                activeEndIdx = activeIndices.length ? Math.max(...activeIndices) : -1;
            }
            const segAIdx = isNaN(rowStartIndex) ? seg : (rowStartIndex + seg);
            const segBIdx = segAIdx + 1;
            if (fullRouteMode && !(segAIdx >= activeStartIdx && segAIdx <= activeEndIdx) && !(segBIdx >= activeStartIdx && segBIdx <= activeEndIdx)) {
                continue;
            }

            let colorClass = 'black';
            if (!isNaN(globalNextIndex) && !isNaN(laterIndex)) {
                if (laterIndex < globalNextIndex) colorClass = 'gray';
                else if (laterIndex === globalNextIndex) colorClass = 'red';
            }
            
            arrow.className = 'direction-arrow ' + colorClass;
            arrow.textContent = isReverseRow ? '←' : '→';
            arrow.style.left = midX + 'px';
            arrow.style.top = rowCenterY + 'px';
            arrow.style.transform = 'translate(-50%, -50%)';
            row.appendChild(arrow);
        }
    });

    // connector cap style moved to CSS <style> block
    
    // 计算全局活动区间（用于连接线灰显判断）
    let activeStartIdx = -1, activeEndIdx = -1;
    if (fullRouteMode) {
        const activeIndices = currentRouteStations.length ? lineInfo.map((s, i) => currentRouteSet.has(s.station_name) ? i : -1).filter(i => i >= 0) : [];
        activeStartIdx = activeIndices.length ? Math.min(...activeIndices) : -1;
        activeEndIdx = activeIndices.length ? Math.max(...activeIndices) : -1;
    }

    // 再绘制每两行之间的平滑垂直连接
    for (let i = 0; i < rows.length - 1; i++) {
        // 在自定义分支模式下，不绘制默认的行间垂直连接线（改由 branch-connector 绘制斜线）
        if (window.isCustomBranchMode) continue;
        
        const upper = rows[i];
        const lower = rows[i + 1];
        const upperStations = Array.from(upper.querySelectorAll('.station-node'));
        const lowerStations = Array.from(lower.querySelectorAll('.station-node'));
        if (upperStations.length === 0 || lowerStations.length === 0) continue;
        
        // 连接侧：偶数索引行（第1、3...）连接右侧，奇数索引行连接左侧
        const side = i % 2 === 0 ? 'right' : 'left';
        const sgn = side === 'right' ? 1 : -1;
        const outward = 35; // 向外偏移以美化转角
        
        function endpointX(row, stations, side) {
            let rect;
            if (side === 'right') {
                rect = row.classList.contains('reverse') ? stations[0].getBoundingClientRect() : stations[stations.length - 1].getBoundingClientRect();
            } else { // left
                rect = row.classList.contains('reverse') ? stations[stations.length - 1].getBoundingClientRect() : stations[0].getBoundingClientRect();
            }
            return rect.left + rect.width / 2 - metroRect.left;
        }
        
        const xUpper = endpointX(upper, upperStations, side);
        const xLower = endpointX(lower, lowerStations, side);
        const yUpper = upper.getBoundingClientRect().top + upper.getBoundingClientRect().height / 2 - metroRect.top;
        const yLower = lower.getBoundingClientRect().top + lower.getBoundingClientRect().height / 2 - metroRect.top;
        
        // 竖直线外移到行端外侧
        const xOut = xUpper + sgn * outward;
        
        // 颜色逻辑：仅在连接线位于当前子路线活动区间内时才着色；并结合“下一站”位置控制是否为未经过（主题色）
        const themeColor = getComputedStyle(metroLine).getPropertyValue('--theme-color').trim() || '#9b5de5';
        const globalNextIndex = parseInt(metroLine.dataset.nextIndex || '-1');
        const upperStartIndex = parseInt(upper.dataset.startIndex || '-1');
        const upperEndIndex = parseInt(upper.dataset.endIndex || '-1');
        const lowerStartIndex = parseInt(lower.dataset.startIndex || '-1');
        const lowerEndIndex = parseInt(lower.dataset.endIndex || '-1');
        function endpointGlobalIndex(rowEl, sideSel, startIdx, endIdx) {
            const isRev = rowEl.classList.contains('reverse');
            if (sideSel === 'right') {
                return isRev ? startIdx : endIdx;
            } else {
                return isRev ? endIdx : startIdx;
            }
        }
        const upIdx = endpointGlobalIndex(upper, side, upperStartIndex, upperEndIndex);
        const lowIdx = endpointGlobalIndex(lower, side, lowerStartIndex, lowerEndIndex);
        const connectorActive = !fullRouteMode ? true : (
            upIdx >= activeStartIdx && upIdx <= activeEndIdx &&
            lowIdx >= activeStartIdx && lowIdx <= activeEndIdx
        );
        const shouldColor = connectorActive && (!isNaN(globalNextIndex) && !isNaN(lowerStartIndex) && globalNextIndex < lowerStartIndex);
        
        // 避免亚像素缝隙：所有关键坐标取整，并结合左侧越界做保护
        const xUpperR = Math.round(xUpper);
        const xLowerR = Math.round(xLower);
        const yUpperR = Math.round(yUpper);
        const yLowerR = Math.round(yLower);
        let xOutR = Math.round(xOut);
        // 左边界保护，避免大外移或方向切换导致的负值
        const xOutRClamped = xOutR;
        
        // 顶部水平过渡段：从行端到外移位置（在圆弧帽下方额外延伸半个厚度以避免缝隙）
        const hTop = document.createElement('div');
        hTop.className = 'connector horizontal';
        hTop.style.position = 'absolute';
        // 顶部水平段：根据朝向决定延伸方向（右向：延伸到右；左向：延伸到左）
        let leftStartTop = Math.min(xUpperR, xOutRClamped);
        let rightEndTop = Math.max(xUpperR, xOutRClamped);
        if (sgn > 0) {
            rightEndTop += thickness / 2; // 朝右时，向右延伸覆盖圆弧帽
        } else {
            leftStartTop -= thickness / 2; // 朝左时，向左延伸覆盖圆弧帽
        }
        // 左边界保护
        leftStartTop = Math.max(0, leftStartTop);
        rightEndTop = Math.max(leftStartTop, Math.min(metroWidth, rightEndTop));
        hTop.style.left = leftStartTop + 'px';
        hTop.style.top = yUpperR + 'px';
        hTop.style.transform = 'translateY(-50%)';
        hTop.style.width = (rightEndTop - leftStartTop) + 'px';
        hTop.style.height = thickness + 'px';
        hTop.style.borderRadius = (thickness / 2) + 'px';
        hTop.style.zIndex = '1';
        if (shouldColor) hTop.style.backgroundColor = themeColor;
        metroLine.appendChild(hTop);
        
        // 顶部圆弧帽（尺寸随厚度、层级更高以覆盖接缝）
        const capTop = document.createElement('div');
        capTop.className = 'connector cap';
        capTop.style.left = (xOutRClamped - thickness / 2) + 'px';
        capTop.style.top = (yUpperR - thickness / 2) + 'px';
        capTop.style.width = thickness + 'px';
        capTop.style.height = thickness + 'px';
        capTop.style.zIndex = '2';
        if (shouldColor) capTop.style.backgroundColor = themeColor;
        metroLine.appendChild(capTop);
        
        // 垂直段：与两端圆弧帽重叠半径
        const v = document.createElement('div');
        v.className = 'connector vertical';
        v.style.position = 'absolute';
        v.style.left = (xOutRClamped - thickness / 2) + 'px';
        v.style.top = (yUpperR - thickness / 2) + 'px';
        v.style.height = (yLowerR - yUpperR + thickness) + 'px';
        v.style.width = thickness + 'px';
        v.style.transform = 'none';
        v.style.borderRadius = (thickness / 2) + 'px';
        v.style.zIndex = '1';
        if (shouldColor) v.style.backgroundColor = themeColor;
        metroLine.appendChild(v);
        
        // 竖直方向箭头（只在竖直段加），仅在活动区间内绘制
        if (connectorActive) {
            const arrowV = document.createElement('div');
            const lowerIsReverse = lower.classList.contains('reverse');
            let laterIndexV;
            if (side === 'right') {
                laterIndexV = lowerIsReverse ? lowerStartIndex : lowerEndIndex;
            } else {
                laterIndexV = lowerIsReverse ? lowerEndIndex : lowerStartIndex;
            }
            let colorClassV = 'black';
            if (!isNaN(globalNextIndex) && !isNaN(laterIndexV)) {
                if (laterIndexV < globalNextIndex) colorClassV = 'gray';
                else if (laterIndexV === globalNextIndex) colorClassV = 'red';
            }
            arrowV.className = 'direction-arrow ' + colorClassV;
            arrowV.textContent = '↓';
            arrowV.style.left = xOutRClamped + 'px';
            arrowV.style.top = Math.round((yUpperR + yLowerR) / 2) + 'px';
            arrowV.style.transform = 'translate(-50%, -50%)';
            metroLine.appendChild(arrowV);
        }
        
        // 底部圆弧帽（尺寸随厚度、层级更高以覆盖接缝）
        const capBottom = document.createElement('div');
        capBottom.className = 'connector cap';
        capBottom.style.left = (xOutRClamped - thickness / 2) + 'px';
        capBottom.style.top = (yLowerR - thickness / 2) + 'px';
        capBottom.style.width = thickness + 'px';
        capBottom.style.height = thickness + 'px';
        capBottom.style.zIndex = '2';
        if (shouldColor) capBottom.style.backgroundColor = themeColor;
        metroLine.appendChild(capBottom);
        
        // 底部水平过渡段：从外移位置回到下行端（在圆弧帽下方额外延伸半个厚度以避免缝隙）
        const hBottom = document.createElement('div');
        hBottom.className = 'connector horizontal';
        hBottom.style.position = 'absolute';
        // 底部水平段：根据朝向决定延伸方向
        // 规则：一端向外延伸覆盖圆弧帽，另一端向行内延伸覆盖行端圆角，确保双侧无缝
        let leftStartBottom = Math.min(xOutRClamped, xLowerR);
        let rightEndBottom = Math.max(xOutRClamped, xLowerR);
        if (sgn > 0) {
            // 右向：起点在左、终点在右
            leftStartBottom -= thickness / 2;   // 向左延伸覆盖底部圆弧帽
            rightEndBottom += thickness / 2;    // 向右延伸少量覆盖行端圆角
        } else {
            // 左向：起点在右、终点在左
            rightEndBottom += thickness / 2;    // 向右延伸覆盖底部圆弧帽
            leftStartBottom -= thickness / 2;   // 向左延伸少量覆盖行端圆角
        }
        // 左边界保护
        leftStartBottom = Math.max(0, leftStartBottom);
        rightEndBottom = Math.max(leftStartBottom, Math.min(metroWidth, rightEndBottom));
        hBottom.style.left = leftStartBottom + 'px';
        hBottom.style.top = yLowerR + 'px';
        hBottom.style.transform = 'translateY(-50%)';
        hBottom.style.width = (rightEndBottom - leftStartBottom) + 'px';
        hBottom.style.height = thickness + 'px';
        hBottom.style.borderRadius = (thickness / 2) + 'px';
        hBottom.style.zIndex = '1';
        if (shouldColor) hBottom.style.backgroundColor = themeColor;
        metroLine.appendChild(hBottom);
    }
}


// 设定徽章背景色
    function setTransferBadgeColors() {
        document.querySelectorAll('.transfer-badge[data-color]').forEach(el => {
            const c = el.getAttribute('data-color');
            if (c) el.style.backgroundColor = c;
        });
    }

    

    // 为换乘站创建旋转多色环
function createTransferRings() {
    document.querySelectorAll('.station-node').forEach(node => {
        const circle = node.querySelector('.station-circle.transfer');
        if (!circle) return;
        
        const themeColor = getComputedStyle(circle).getPropertyValue('--theme-color').trim() || '#9b5de5';
        const badgeEls = node.querySelectorAll('.transfer-badge[data-color]');
        const colors = [themeColor];
        
        badgeEls.forEach(b => {
            const c = b.getAttribute('data-color');
            if (c) colors.push(c);
        });
        
        const share = 100 / colors.length;
        let start = 0;
        const parts = colors.map((clr) => {
            const end = start + share;
            const seg = `${clr} ${start}% ${end}%`;
            start = end;
            return seg;
        });
        
        const ring = document.createElement('span');
        ring.style.position = 'absolute';
        ring.style.inset = '-2px';
        ring.style.borderRadius = '50%';
        ring.style.background = `conic-gradient(${parts.join(', ')})`;
        ring.style.zIndex = '0';
        
        // 非当前子路线的换乘环保持静止；仅对活动且未经过的换乘站启用旋转
        const isInactive = circle.classList.contains('inactive');
        if (!circle.classList.contains('passed') && !isInactive) {
            ring.style.animation = 'spin 4s linear infinite';
        }
        
        circle.appendChild(ring);
    });
}

// 滚动到下一站
function scrollToNextStation() {
    const nextStation = document.querySelector('.station-node .station-circle.next');
    if (nextStation) {
        nextStation.closest('.station-node').scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center', 
            inline: 'nearest' // 避免水平滚动导致内容抖动与画布外定位
        });
    }
}

// 窗口大小变化时重新布局
function handleResize() {
    if (JSON.parse(document.getElementById('is-loop-data')?.textContent || 'false')) {
        renderLoopMap();
    } else {
        createZigzagLayout();
        applyCustomLayoutStyles();
        computeRailAndConnectors();
        setTransferBadgeColors();
        createTransferRings();
    }
}

function init() {
    if (JSON.parse(document.getElementById('is-loop-data')?.textContent || 'false')) {
        renderLoopMap();
        // 注释掉自动滚动到下一站，让页面保持在最上方
        // scrollToNextStation();
        window.addEventListener('resize', handleResize);
    } else {
        createZigzagLayout();
        applyCustomLayoutStyles();
        computeRailAndConnectors();
        setTransferBadgeColors();
        createTransferRings();
        // 注释掉自动滚动到下一站，让页面保持在最上方
        // scrollToNextStation();
        // 线性布局首次渲染后做一次延迟复测，修复 direction=1 时初次宽度与位置不稳定导致的左侧挤出
        const metroLine = document.getElementById('metro-line');
        if (metroLine && metroLine.dataset.settle !== 'done') {
            metroLine.dataset.settle = 'pending';
            requestAnimationFrame(() => {
                setTimeout(() => {
                    metroLine.dataset.settle = 'done';
                    createZigzagLayout();
                    applyCustomLayoutStyles();
                    computeRailAndConnectors();
                    setTransferBadgeColors();
                    createTransferRings();
                }, 60);
            });
        }
        window.addEventListener('resize', handleResize);
    }
}

function renderLoopMap() {
    const rl = document.getElementById('ring-line');
    const ml = document.getElementById('metro-line');
    if (!rl || !ml) return;
    rl.style.display = '';
    ml.style.display = 'none';
    rl.innerHTML = '';

    const container = document.querySelector('.line-map-container');
    const reserve = 160; // 为外侧标签和安全边留白，防止溢出
    const minWidth = 680; // 缩小最小宽度
    // 使用更稳定的尺寸测量，避免初次渲染因容器状态或滚动条导致偏差
    const containerRectWidth = Math.floor(container.getBoundingClientRect().width || container.clientWidth || container.offsetWidth || 0);
    const width = Math.max(minWidth, containerRectWidth - reserve);
    const height = Math.max(320, Math.min(520, Math.round(width * 0.45)));
    const margin = 40;
    const W = width - margin * 2;
    const H = height - margin * 2;
    const radius = Math.round(Math.min(W, H) * 0.12);
    const ns = 'http://www.w3.org/2000/svg';

     const svg = document.createElementNS(ns, 'svg');
     svg.setAttribute('width', String(width));
     svg.setAttribute('height', String(height));
     svg.style.display = 'block';
     // 让环线容器成为定位上下文，并设置固定尺寸
     rl.style.position = 'relative';
    rl.style.margin = '0 auto'; // 居中，避免贴边
    rl.style.width = `${width}px`;
    rl.style.height = `${height}px`;
    // 让SVG与站点层叠在同一平面，SVG在下、站点在上
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.zIndex = '0';

    const base = document.createElementNS(ns, 'rect');
    base.setAttribute('x', String(margin));
    base.setAttribute('y', String(margin));
    base.setAttribute('width', String(W));
    base.setAttribute('height', String(H));
    base.setAttribute('rx', String(radius));
    base.setAttribute('ry', String(radius));
    base.setAttribute('fill', 'none');
    base.setAttribute('stroke', '#ddd');
    base.setAttribute('stroke-width', '15');
    svg.appendChild(base);

    const group = document.createElement('div');
    group.style.position = 'absolute';
    group.style.left = '0';
    group.style.top = '0';
    group.style.width = `${width}px`;
    group.style.height = `${height}px`;
    group.style.zIndex = '1';
    rl.appendChild(svg);
    rl.appendChild(group);

    const totalLen = (base.getTotalLength && base.getTotalLength()) || (2 * (W + H));
    const n = lineInfo.length;
    const nextIndex = lineInfo.findIndex(s => s.station_name === nextStationName);

    // 根据站点编号重排：将编号'01'锚定到顶边中点，其余按逆时针一周布局（并去重避免重复首尾站）
    const getStationNum = (s) => {
        const idx = s.station_index;
        if (Array.isArray(idx)) {
            const v = idx[idx.length - 1];
            const m = String(v || '').match(/^\d+$/);
            return m ? parseInt(v, 10) : NaN;
        } else {
            const m = String(idx || '').match(/^\d+$/);
            return m ? parseInt(idx, 10) : NaN;
        }
    };
    const entries = lineInfo.map((s, i) => ({ s, i, num: getStationNum(s) }));
    entries.sort((A, B) => {
        const a = isNaN(A.num) ? Number.MAX_SAFE_INTEGER : A.num;
        const b = isNaN(B.num) ? Number.MAX_SAFE_INTEGER : B.num;
        return a - b;
    });
    const ordered = entries.map(e => e.s);
    // 去重：以站名为键，保留首个出现的站
    const seen = new Set();
    const orderedUnique = [];
    for (const s of ordered) {
        const key = s.station_name || JSON.stringify(s.station_index);
        if (seen.has(key)) continue;
        seen.add(key);
        orderedUnique.push(s);
    }
    const nU = orderedUnique.length;
    const anchorPos = orderedUnique.findIndex(s => getStationNum(s) === 1);
    const seg = totalLen / nU;
    const anchorOffset = (W - 2 * radius) / 2; // 顶边直线段的中点
    const pts = [];
    const nodes = [];
    const dPos = [];

    for (let i = 0; i < nU; i++) {
        const stepsFromAnchor = ((i - (anchorPos >= 0 ? anchorPos : 0)) % nU + nU) % nU;
        const d = (anchorOffset - seg * stepsFromAnchor + totalLen) % totalLen; // 逆时针：长度递减
        const pt = (base.getPointAtLength ? base.getPointAtLength(d) : { x: margin + W / 2, y: margin });
        pts.push(pt);
        const tmp = document.createElement('div');
        tmp.innerHTML = createStationNode(orderedUnique[i]);
        const node = tmp.firstElementChild;
        node.style.position = 'absolute';
        node.style.left = `${pt.x}px`;
        node.style.top = `${pt.y}px`;
        node.style.transform = 'translate(-50%, -50%)';
        // 站名外侧，换乘内侧（按所在边）
        // 侧边特殊处理：用户要求侧边站点“文字左下对齐站点，站点左侧水平排列换乘数字”
        // 顶/底边保持默认CSS样式（文字上偏右，换乘下垂直）
        const labels = node.querySelector('.station-labels');
        const badges = node.querySelector('.transfer-badges');
        const tol = 20;
        
        // 判断是否在左右侧边（垂直段）
        const isLeft = Math.abs(pt.x - margin) < tol;
        const isRight = Math.abs(pt.x - (margin + W)) < tol;
        
        if (isLeft) {
            if (labels) {
                labels.style.left = '-100%'; // 站点左侧
                labels.style.bottom = '-500%'; // 站点上方
            }
            if (badges) {
                badges.style.top = '50%';
                badges.style.bottom = 'auto';
                badges.style.left = '10px'; // 距离左边界38px
                badges.style.right = 'auto';
                badges.style.transform = 'translateY(-50%)';
                badges.style.flexDirection = 'row';
                badges.style.gap = '2px';
            }
        } else if (isRight) {
            if (labels) {
                labels.style.left = '120%'; // 站点右侧
                labels.style.bottom = '0%'; // 站点上方
            }
            if (badges) {
                badges.style.top = '50%';
                badges.style.bottom = 'auto';
                badges.style.left = 'auto';
                badges.style.right = '10px'; 
                badges.style.transform = 'translateY(-50%)';
                badges.style.flexDirection = 'row';
                badges.style.gap = '2px';
            }
        }
        // 静态线路图：不做已过站灰显
        group.appendChild(node);
        nodes.push(node);
        dPos.push(d);
    }

    // 边段方向箭头：拐角处不显示（derection=0逆时针，derection=1顺时针）
    for (let i = 0; i < nU; i++) {
        const pA = pts[i];
        const pB = pts[(derection === 0 ? (i + 1) : (i - 1 + nU)) % nU];
        const midX = (pA.x + pB.x) / 2;
        const midY = (pA.y + pB.y) / 2;
        const dx = pB.x - pA.x;
        const dy = pB.y - pA.y;
        const inTopLeft = (x, y) => (x >= margin && x <= margin + radius) && (y >= margin && y <= margin + radius);
        const inTopRight = (x, y) => (x >= margin + W - radius && x <= margin + W) && (y >= margin && y <= margin + radius);
        const inBottomRight = (x, y) => (x >= margin + W - radius && x <= margin + W) && (y >= margin + H - radius && y <= margin + H);
        const inBottomLeft = (x, y) => (x >= margin && x <= margin + radius) && (y >= margin + H - radius && y <= margin + H);
        const nearCorner = (x, y) => inTopLeft(x, y) || inTopRight(x, y) || inBottomRight(x, y) || inBottomLeft(x, y);
        if (nearCorner(midX, midY) || nearCorner(pA.x, pA.y) || nearCorner(pB.x, pB.y)) {
            continue;
        }
        const arrow = document.createElement('div');
        arrow.className = 'direction-arrow black';
        let ch;
        if (Math.abs(dx) >= Math.abs(dy)) {
            ch = dx > 0 ? '→' : '←';
        } else {
            ch = dy > 0 ? '↓' : '↑';
        }
        arrow.textContent = ch;
        arrow.style.position = 'absolute';
        arrow.style.left = `${midX}px`;
        arrow.style.top = `${midY}px`;
        arrow.style.transform = 'translate(-50%, -50%)';
        group.appendChild(arrow);
    }

    // 颜色叠加：静态主题色整环（移除灰段与“已过站”标记）
    const themeColor = getComputedStyle(document.querySelector('.line-map')).getPropertyValue('--theme-color').trim() || '#9b5de5';
    const colored = document.createElementNS(ns, 'rect');
    colored.setAttribute('x', String(margin));
    colored.setAttribute('y', String(margin));
    colored.setAttribute('width', String(W));
    colored.setAttribute('height', String(H));
    colored.setAttribute('rx', String(radius));
    colored.setAttribute('ry', String(radius));
    colored.setAttribute('fill', 'none');
    colored.setAttribute('stroke', themeColor);
    colored.setAttribute('stroke-width', '15');
    svg.appendChild(colored);

    // 环线“已走过”规则：根据是否有终点站与方向标记灰段与站点
    (function applyLoopPassed() {
        const nextIdxU = orderedUnique.findIndex(s => s.station_name === nextStationName);
        const hasTerminal = JSON.parse(document.getElementById('loop-has-terminal-data')?.textContent || 'false');
        const terminalName = JSON.parse(document.getElementById('loop-terminal-station-data')?.textContent || 'null');
        const terminalIdxU = orderedUnique.findIndex(s => s.station_name === terminalName);
        if (nextIdxU < 0) return; // 无下一站，跳过

        // 方向：derection=0 按 i+1 前进；derection=1 按 i-1 前进
        const stepNext = (i) => (derection === 0 ? (i + 1) % nU : (i - 1 + nU) % nU);
        const stepPrev = (i) => (derection === 0 ? (i - 1 + nU) % nU : (i + 1) % nU);

        // 站点灰显列表
        let passedIndices = [];
        let startIdxForArc = -1;
        let L = 0; // 灰线长度
        let shouldDrawGrayLine = false; // 是否绘制灰线

        // 判断下一站是否为终点站
        const isNextStationTerminal = (hasTerminal && nextIdxU === terminalIdxU);

        if (isNextStationTerminal) {
            // 如果下一站就是终点站，则除了下一站本身，所有其他站点都视为已过站
            for (let i = 0; i < nU; i++) {
                if (i !== nextIdxU) {
                    passedIndices.push(i);
                }
            }

            // 当下一站是终点站时，所有路线段都应为灰色
            L = totalLen; // 灰线长度等于总长度
            startArcPos = dPos[nextIdxU]; // 灰线起始位置可以任意设置，这里选择下一站的位置
            shouldDrawGrayLine = true;

        } else if (hasTerminal && terminalIdxU >= 0) {
            // 有终点站，且下一站不是终点站：从终点站到下一站（不含下一站）之间标记为已过
            let i = terminalIdxU;
            startIdxForArc = terminalIdxU;
            while (i !== nextIdxU) {
                if (i !== terminalIdxU) {
                    passedIndices.push(i);
                }
                i = stepNext(i);
            }
            // 计算灰线长度和起始位置
            const startD = dPos[startIdxForArc];
            const endD = dPos[nextIdxU];
            if (derection === 0) {
                L = (startD - endD + totalLen) % totalLen;
                startArcPos = endD;
            } else {
                L = (endD - startD + totalLen) % totalLen;
                startArcPos = startD;
            }
            shouldDrawGrayLine = true;

        } else {
            // 无终点站：仅上一站标记为已过，灰线覆盖上一站到下一站之间的段
            const prevIdxU = stepPrev(nextIdxU);
            passedIndices.push(prevIdxU);
            startIdxForArc = prevIdxU;
            // 计算灰线长度和起始位置
            const startD = dPos[startIdxForArc];
            const endD = dPos[nextIdxU];
            if (derection === 0) {
                L = (startD - endD + totalLen) % totalLen;
                startArcPos = endD;
            } else {
                L = (endD - startD + totalLen) % totalLen;
                startArcPos = startD;
            }
            shouldDrawGrayLine = true;
        }

        // 标记站点为已过（灰、静止）
        passedIndices.forEach(i => {
            const circle = nodes[i]?.querySelector('.station-circle');
            if (circle) circle.classList.add('passed');
        });

        // 绘制灰色已过线段
        if (shouldDrawGrayLine && L > 0) {
            const passedStroke = document.createElementNS(ns, 'rect');
            passedStroke.setAttribute('x', String(margin));
            passedStroke.setAttribute('y', String(margin));
            passedStroke.setAttribute('width', String(W));
            passedStroke.setAttribute('height', String(H));
            passedStroke.setAttribute('rx', String(radius));
            passedStroke.setAttribute('ry', String(radius));
            passedStroke.setAttribute('fill', 'none');
            passedStroke.setAttribute('stroke', '#cfcfcf');
            passedStroke.setAttribute('stroke-width', '15');
            passedStroke.setAttribute('stroke-linecap', 'butt');
            // 单段灰：灰段长度 L，剩余为透明（总长 - L）
            passedStroke.setAttribute('stroke-dasharray', `${L} ${totalLen - L}`);
            // 从正确的起点开始绘制（随方向）
            passedStroke.setAttribute('stroke-dashoffset', String((totalLen - startArcPos) % totalLen));
            svg.appendChild(passedStroke);
        }
    })();

    // 补充换乘徽章颜色与旋转环（保留）
    setTransferBadgeColors();
    createTransferRings();

    // 首次渲染后做一次延迟复测，避免初次布局时宽度尚未稳定导致两侧溢出
    if (rl && rl.dataset.settle !== 'done') {
        rl.dataset.settle = 'pending';
        requestAnimationFrame(() => {
            setTimeout(() => {
                rl.dataset.settle = 'done';
                renderLoopMap();
            }, 60);
        });
    }
}

document.addEventListener('DOMContentLoaded', init);
</script>
{% endblock %}
